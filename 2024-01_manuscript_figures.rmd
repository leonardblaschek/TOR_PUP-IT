---
title: "TORC interactome figures"
author: "Leonard Blaschek"
output: html_document
bibliography: refs.bib
link-citations: true
---

# *Note*

This workflow takes the data generated by `2023-11_TOR_PPIN.rmd`, `2023-11_TOR_PPIN_vis.rmd`, `2023-11_TOR_phospho.rmd` and `2023-11_TOR_PPIN_Nb.rmd` to create the analyses and figures shown in the manuscript.

Several instances of system calls to additional software (`DEPTH, MoMo, curl, wget, wkhtmltopdf, alphafold_disorder`) were disabled, pulling the pre-computed results from the repository data file, to ensure wide compatibility of this script. If you want to re-run these calculations, the used commands are included, but either commented-out or present in non-evaluated code chunks.

```{r setup}
knitr::opts_chunk$set(
  out.width = "100%"
)

library(eulerr)
library(clusterProfiler)
library(vegan)
library(ggdendro)
library(biomartr)
library(patchwork)
library(ggtext)
library(ggrepel)
library(showtext)
library(tinytable)
library(ggbeeswarm)
library(tukeygrps)
library(ComplexUpset)
library(signs)
library(igraph)
library(ggraph)
library(tidygraph)
library(ggforce)
library(ggridges)
library(gt)
library(ggseqlogo)
library(tidyverse)

# Increase timeout for {Biomartr} calls
options(timeout = 50000)
set.seed(1234)

#### import Helvetica ####
# If you don't have Helvetica (or the files are named/located differently),
# make these paths point toward some other font files to allow the code to run
font_add(
  "Helvetica",
  regular = "HelveticaLTStd-Roman.otf",
  italic = "HelveticaLTStd-Obl.otf",
  bold = "HelveticaLTStd-Bold.otf",
  bolditalic = "HelveticaLTStd-BoldObl.otf"
)
showtext_auto()
showtext_opts(dpi = 200)

text_size <- 6
ggtext_size <- text_size / (14 / 5)

#### generating plot theme ####
theme_leo <- function(base_size = text_size,
                      base_family = "Helvetica") {
  theme_minimal(
    base_size = base_size,
    base_family = base_family
  ) %+replace%
    theme(
      strip.text = element_markdown(hjust = 0),
      axis.ticks = element_blank(),
      axis.text.x = element_markdown(
        colour = "black",
        margin = margin(1, 1, 1, 1),
        size = text_size
      ),
      axis.text.y = element_markdown(
        colour = "black",
        angle = 0,
        vjust = 0.5,
        hjust = 1,
        margin = margin(1, 1, 1, 1),
        size = text_size
      ),
      axis.title = element_blank(),
      axis.line = element_line(
        linewidth = 0.4,
        colour = "black",
        lineend = "square"
      ),
      plot.title = element_markdown(size = text_size * 1.2, hjust = 0.5),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.spacing = unit(1.5, "mm"),
      legend.position = "bottom",
      legend.text = element_text(size = rel(1)),
      legend.key.height = unit(4, "mm"),
      complete = TRUE
    )
}

pal_ostwald_disc <- c(
  "#275d95",
  "#e8c245",
  "#d25952",
  "#7ab6c4"
)

# Figure widths
twocol <- 18 / 2.54
onehalfcol <- 14 / 2.54
onecol <- 9 / 2.54

# Function to turn '0.0' into '0' in ggplots
flat_zero <- function(l) {
  if (str_detect(paste(l, collapse = ";"), "\\.")) {
    max.decimals <- max(nchar(str_extract(l, "\\.[0-9]+")), na.rm = T) - 1
  } else {
    max.decimals <- 0
  }
  lnew <- formatC(l,
    replace.zero = T, zero.print = "0",
    digits = max.decimals, format = "f", preserve.width = T
  )
  return(lnew)
}

# Function to download locus ID from of accessions
get_gene <- function(uniprot_ID) {
  url <- paste("https://rest.uniprot.org/uniprotkb/",
    uniprot_ID, "?format=tsv",
    sep = "", collapse = ""
  )
  data <- read_tsv(url, col_types = cols_only(`Gene Names` = "c")) |>
    pull(`Gene Names`) |>
    str_extract(regex("at[[:digit:]mc]g[:digit:]+", ignore_case = TRUE)) |>
    str_to_upper()
}

## Set working folder
out_path <- "data/output/"

# POIs
TOR <- c("Q9FR53", "TOR")
LST8 <- c("Q9LV27", "LST8-1")
RAPTOR <- c("Q93YQ1", "RAPTOR1")
FKBP12 <- c("P20081", "*Sc*FKBP")

bait_list <- list(
  "LST8" = LST8,
  "RAPTOR" = RAPTOR,
  "FKBP12" = FKBP12,
  "TOR" = TOR
)

# StringDB cutoff for experimental evidence strength
e_cut <- 0.25
```

# Load published interaction data

## StringDB

```{r}
TOR_db <- read_tsv(paste0(
  "https://string-db.org/api/tsv/interaction_partners?identifiers=",
  TOR[1],
  "&network_type=physical&required_score=50&limit=1000"
)) |>
  filter(escore > e_cut) |>
  mutate(across(c(stringId_A, stringId_B), ~ str_remove(.x, fixed("3702."))))

LST8_db <- read_tsv(
  paste0(
    "https://string-db.org/api/tsv/interaction_partners?identifiers=",
    LST8[1],
    "&network_type=physical&required_score=50&limit=1000"
  )
) |>
  filter(escore > e_cut) |>
  mutate(across(c(stringId_A, stringId_B), ~ str_remove(.x, fixed("3702."))))

RAPTOR_db <- read_tsv(
  paste0(
    "https://string-db.org/api/tsv/interaction_partners?identifiers=",
    RAPTOR[1],
    "&network_type=physical&required_score=50&limit=1000"
  )
) |>
  filter(escore > e_cut) |>
  mutate(across(c(stringId_A, stringId_B), ~ str_remove(.x, fixed("3702."))))

TORC_db <- bind_rows(TOR_db, LST8_db, RAPTOR_db) |>
  distinct(stringId_B, .keep_all = TRUE)

db_list <- list(LST8_db, RAPTOR_db, TOR_db, TORC_db)

TORC_db
```

## Van Leene et al. 2019

Loading reformatted supplementary data from @VanLeene2019.

```{r}
leene_data <- read_tsv("data/published/leene_hits.tsv")

leene_loci <- leene_data |>
  pull(gene)

stringIds <- read_tsv(
  paste0(
    "https://string-db.org/api/tsv/get_string_ids?identifiers=",
    leene_loci,
    "&species=3702&echo_query=1"
  ),
  skip_empty_rows = FALSE
) |>
  mutate(stringId = str_remove(stringId, fixed("3702."))) |>
  distinct()

leene_data <- leene_data |>
  left_join(
    stringIds,
    by = join_by("gene" == "queryItem")
  ) |>
  mutate(stringId = case_when(
    gene == "AT1G53880" ~ "F4HTE0", # manually correct stringIds
    stringId == "Q9T0J7" ~ "Q8H1F0", # manually correct stringIds
    TRUE ~ stringId
  ))

leene_proteins <- leene_data |>
  pull(stringId) |>
  unique()

leene_proteins
```

## Persyn et al. 2024

Loading reformatted supplementary data from @VanLeene2019.

```{r}
persyn_ap <- read_tsv("data/published/MCP_AP.tsv")
persyn_pl <- read_tsv("data/published/MCP_PL.tsv")
persyn_data <- persyn_ap |>
  select("gene" = `Prey Accession`, "method" = Method, "bait" = `Bait Symbol`) |>
  bind_rows(
    persyn_pl |>
      select("gene" = `Prey Accession`, "method" = Method, "bait" = `Bait Symbol`)
  ) |>
  distinct()

persyn_loci <- persyn_data |>
  pull(gene) |>
  unique()

stringIds <- read_tsv(
  paste0(
    "https://string-db.org/api/tsv/get_string_ids?identifiers=",
    persyn_loci,
    "&species=3702&echo_query=1"
  ),
  skip_empty_rows = FALSE
) |>
  mutate(stringId = str_remove(stringId, fixed("3702."))) |>
  distinct()

persyn_data <- persyn_data |>
  left_join(
    stringIds,
    by = join_by("gene" == "queryItem")
  ) |>
  mutate(stringId = case_when(
    gene == "AT1G53880" ~ "F4HTE0", # manually correct stringIds
    gene == "AT5G63620" ~ "F4KAS6", # manually correct stringIds
    TRUE ~ stringId
  ))

persyn_proteins <- persyn_data |>
  pull(stringId) |>
  unique()

persyn_proteins
```


### Check that StringDB data is limited to the reference proteome

```{r, results='asis'}
ref_proteome <- seqinr::read.fasta(
  "data/proteome/FP_At_ref.fasta",
  as.string = TRUE
)

ref_ids <- str_extract(names(ref_proteome), ".+\\|(.+)\\|.+", group = 1)

test <- persyn_data |>
  mutate(found = str_detect(stringId, str_flatten(ref_ids, collapse = "|", na.rm = T)))

cat(
  paste0(
    sum(
      str_detect(
        c(
          pull(
            TORC_db,
            stringId_B
          ),
          leene_proteins,
          persyn_proteins
        ),
        str_flatten(
          ref_ids,
          collapse = "|",
          na.rm = T
        )
      )
    ),
    " out of ",
    nrow(TORC_db) + length(leene_proteins) + length(persyn_proteins),
    " proteins reported in StringDB as interactors of the TOR complex are in the reference proteome used for our analyses."
  )
)

# 285 expected proteins; if more, the database changed
```

## Direct phosphotargets from Van Leene et al. (2019)

```{r}
leene <- tribble(
  ~locus, ~protein, ~name,
  "AT1G29400", "Q8VWF5", "AML5",
  "AT3G50370", "A0A1I9LPZ1", "AT3G50370",
  "AT3G49590", "Q9SCK0", "ATG13A",
  "AT3G53930", "F4JBP3", "ATG1B",
  "AT5G38640", "Q9FFV8", "eIF2B-d1",
  "AT5G43870", "Q9LKC2", "FL1",
  "AT3G15040", "Q9LKA1", "S40-7",
  "AT5G35980", "Q8RWH3", "YAK1"
)

tt(
  leene,
  caption = "Proteins identified as direct phosphotargets of TOR kinase by Van Leene et al. (2019)."
)
```

# Phenotyping

## RAPTOR1 Complementation 

### Load data

```{r}
comp_data <- read_tsv("data/phenotyping/RAPTOR_comp.tsv") |>
  fill(genotype, line, .direction = "down") |>
  mutate(
    line = paste("Line", line),
    line = ordered(line, levels = c("Line 3", "Line 8", "Line 9", "Line 14")),
    genotype = str_replace(genotype, "Col-0", "WT"),
    genotype = ordered(genotype, levels = c("WT", "*rb5*", "*rb5* RAPTOR1::PafA"))
  ) |>
  filter(line != "Line 9") # 3 lines are enough
```

### Plot

```{r}
letters <- letter_groups(
  comp_data,
  length,
  genotype,
  "tukey",
  line,
  print_position = "above",
  print_adjust = 0.5
)

raptor_comp_plot <- ggplot(
  comp_data,
  aes(x = genotype, y = length)
) +
  stat_summary(
    aes(fill = genotype),
    geom = "bar",
    fun = "median",
    width = 0.7,
    fatten = 1,
    position = position_dodge(width = 0.75)
  ) +
  geom_quasirandom(
    aes(fill = genotype),
    colour = "white",
    shape = 22,
    size = 1,
    stroke = 0.4,
    width = 0.1,
    dodge.width = 0.75
  ) +
  geom_text(
    data = letters,
    aes(label = Letters),
    family = "Helvetica",
    size = ggtext_size
  ) +
  coord_cartesian(ylim = c(0, NA)) +
  labs(y = "Root length after 9 d [mm]") +
  scale_fill_manual(
    values = pal_ostwald_disc[c(1, 3, 4)],
    guide = guide_legend(override.aes = list(shape = NA))
  ) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  theme_leo() +
  theme(
    axis.title.y = element_text(),
    axis.text.x = element_blank(),
    legend.position = "bottom",
    legend.text = element_markdown(),
    legend.direction = "horizontal",
    legend.title = element_blank(),
    legend.margin = margin(-10, 2, 0, 0),
    legend.key.height = unit(2.5, "mm"),
    legend.key.width = unit(2.5, "mm"),
    strip.placement = "inside",
    panel.spacing = unit(3, "mm")
  ) +
  facet_wrap(~line, nrow = 1)

raptor_comp_plot

# ggsave(
#   "rb5_comp.pdf",
#   width = 90,
#   height = 45,
#   units = "mm"
# )
```

## AZD treatment

### Load data

```{r}
comp_data <- read_tsv("data/phenotyping/azd.tsv") |>
  filter(time == "72 h")

n_azd <- comp_data |>
  group_by(treatment) |>
  tally()
```

### Plot

```{r}
letters <- letter_groups(
  comp_data,
  length,
  treatment,
  "tukey",
  print_position = "above",
  print_adjust = 0.75
)

azd_plot <- ggplot(
  comp_data,
  aes(x = treatment, y = length)
) +
  geom_quasirandom(
    aes(
      fill = treatment
    ),
    colour = "white",
    shape = 22,
    size = 2,
    stroke = 0.4,
    width = 0.25
  ) +
  stat_summary(
    aes(group = treatment),
    geom = "crossbar",
    fun = "median",
    width = 0.5,
    fatten = 1
  ) +
  geom_text(
    data = letters,
    aes(label = Letters),
    family = "Helvetica",
    size = ggtext_size
  ) +
  # coord_cartesian(ylim = c(0, NA)) +
  labs(y = "Hypocotyl length after 3 d [mm]") +
  scale_fill_manual(values = pal_ostwald_disc[c(1, 3, 4)]) +
  theme_leo() +
  theme(
    axis.title.x = element_blank(),
    axis.title.y = element_text(),
    axis.text.x = element_markdown(
      vjust = 1
    ),
    legend.position = "none"
  )

azd_plot

# ggsave(
#   "AZD.pdf",
#   width = 45,
#   height = 45,
#   units = "mm"
# )
```

## FKBP12 Complementation 

### Load data

```{r}
comp_data <- readxl::read_xlsx(
  "data/phenotyping/FKBP12_area.xlsx",
  sheet = 2
) |>
  filter(sample %in% c("Col0", "FKBP12_1", "FKBP12_18", "FKBP12_22")) |> # select three representative lines
  mutate(
    sample = str_replace(sample, "Col0", "WT"),
    sample = str_replace(sample, "FKBP12_([:digit:]+)", "*Sc*FKBP<br>line \\1"),
    sample = ordered(sample, levels = unique(sample)),
    cond = case_when(
      cond == "cont" ~ "Control",
      TRUE ~ "10 µM Rapamycin"
    ),
    cond = ordered(cond, levels = c("Control", "10 µM Rapamycin"))
  ) |>
  filter(day != "5d") # one time-point is enough
```

### Plot

```{r}
letters <- comp_data |>
  unite("group", sample, cond, sep = "-") |>
  letter_groups(
    area,
    group,
    "tukey",
    day,
    print_position = "above",
    print_adjust = 0.25
  ) |>
  separate(group, into = c("sample", "cond"), sep = "-") |>
  mutate(
    area = case_when(
      day == "0d" ~ area + 0.01,
      TRUE ~ area
    ),
    sample = ordered(sample, levels = unique(comp_data$sample)),
    cond = ordered(cond, levels = c("Control", "10 µM Rapamycin"))
  )

day_labels <- c(
  "0d" = "Day 0",
  "5d" = "Day 5",
  "8d" = "Day 8"
)

comp_plot <- ggplot(
  comp_data,
  aes(
    x = sample,
    y = area,
    group = cond
  )
) +
  stat_summary(
    aes(fill = cond),
    geom = "bar",
    fun = "median",
    width = 0.7,
    fatten = 1,
    position = position_dodge(width = 0.75)
  ) +
  geom_quasirandom(
    aes(fill = cond),
    colour = "white",
    shape = 22,
    size = 1,
    stroke = 0.4,
    width = 0.1,
    dodge.width = 0.75
  ) +
  geom_text(
    data = letters,
    aes(label = Letters),
    family = "Helvetica",
    size = ggtext_size,
    position = position_dodge(width = 0.75)
  ) +
  coord_cartesian(ylim = c(0, NA)) +
  labs(y = "Leaf area [mm<sup>2</sup>]") +
  scale_fill_manual(
    values = pal_ostwald_disc[c(1, 3)],
    guide = guide_legend(override.aes = list(shape = NA))
  ) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  theme_leo() +
  theme(
    axis.title.y = element_markdown(),
    legend.position = c(0, 1),
    legend.justification = c(0, 1),
    legend.key.height = unit(2.5, "mm"),
    legend.key.width = unit(2.5, "mm"),
    legend.title = element_blank(),
    panel.spacing = unit(3, "mm")
  ) +
  facet_wrap(~day, nrow = 1, labeller = labeller(day = day_labels))

comp_plot
```

# *N. benthamiana* PUP-IT

## Load data

```{r}
Nb_interactions <- read_tsv(
  "data/Nb_output/FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE_PPI_FC_annotated.tsv"
) |>
  group_by(batch, group1, group2, protein) |>
  # sort so we preferentially drop duplicates without annotations
  arrange(desc(Synonyms), .by_group = TRUE) |>
  # drop duplicated protein–gene matches
  distinct(protein, .keep_all = TRUE) |>
  ungroup()

Nb_inv <- Nb_interactions |>
  mutate(logFC = -logFC) |>
  rename(
    "group2" = "group1",
    "group1" = "group2"
  )


Nb_interactions <- Nb_interactions |>
  bind_rows(Nb_inv)

Nb_interactions
```

## Format data

```{r}
Nb_LST8 <- Nb_interactions |>
  filter(
    group1 == "Nb_35S_LST8" &
      group2 == "Nb_35S_GFP"
  ) |>
  rename("LST8" = "logFC", "LST8_P" = "adjPval") |>
  select(protein, LST8, LST8_P, c(23:29))

Nb_RAPTOR <- Nb_interactions |>
  filter(
    group1 == "Nb_35S_RAPTOR" &
      group2 == "Nb_35S_GFP"
  ) |>
  rename("RAPTOR" = "logFC", "RAPTOR_P" = "adjPval") |>
  select(protein, RAPTOR, RAPTOR_P, c(23:29))

Nb_volc_data <- full_join(Nb_RAPTOR, Nb_LST8) |>
  mutate(
    evidence = case_when(
      protein %in% c("LST8", "RAPTOR") ~ "Bait",
      protein == TOR[1] ~ "TOR",
      ((LST8 > 1) & (LST8_P < 0.05) |
        (RAPTOR > 1) & (RAPTOR_P < 0.05)) &
        protein %in% TORC_db$stringId_B ~ "StringDB",
      ((LST8 > 1) & (LST8_P < 0.05) |
        (RAPTOR > 1) & (RAPTOR_P < 0.05)) ~ "Enriched",
      TRUE ~ "Background"
    ),
    evidence = ordered(evidence, levels = c(
      "Background",
      "Enriched",
      "StringDB",
      "Bait",
      "TOR"
    )),
    label = case_when(
      evidence == "TOR" ~ "*Nb*TOR",
      protein == "LST8" ~ "*At*LST8-1",
      protein == "RAPTOR" ~ "*At*RAPTOR1",
      TRUE ~ protein
    )
  ) |>
  arrange(evidence)
```

## Plot graph

```{r}
bait_dep <- Nb_volc_data |>
  filter(
    (((LST8 > 1) & (LST8_P < 0.05)) &
      ((RAPTOR < 1) | (RAPTOR_P > 0.05))) |
      (((RAPTOR > 1) & (RAPTOR_P < 0.05)) &
        ((LST8 < 1) | (LST8_P > 0.05)))
  )
total <- Nb_volc_data |>
  filter(
    ((RAPTOR > 1) & (RAPTOR_P < 0.05) |
      (LST8 > 1) & (LST8_P < 0.05))
  )

Nb_volc <- ggplot(
  Nb_volc_data,
  aes(
    x = LST8,
    y = RAPTOR
  )
) +
  geom_abline(
    slope = 1,
    linewidth = 0.4,
    linetype = 2
  ) +
  geom_point(
    aes(
      fill = evidence,
      size = evidence
    ),
    shape = 21,
    colour = "white",
    stroke = 0.2
  ) +
  geom_richtext(
    data = filter(Nb_volc_data, str_detect(protein, TOR[1]) | str_detect(protein, "LST8|RAPTOR")),
    aes(label = label),
    label.size = NA,
    fill = rgb(1, 1, 1, 0),
    family = "Helvetica",
    size = ggtext_size,
    nudge_x = -0.3,
    nudge_y = 0.6,
    hjust = 0
  ) +
  annotate(
    "richtext",
    label = paste0(
      "Identified paralogs of <b>",
      "<span style='color:#275d95'>",
      nrow(filter(Nb_volc_data, evidence %in% c("Bait", "TOR", "StringDB"))),
      "</span>/",
      length(unique(TORC_db$stringId_B)),
      "</b><br>StringDB TORC interactors"
    ),
    x = 6,
    y = -4,
    hjust = 1,
    family = "Helvetica",
    size = ggtext_size,
    label.size = NA,
    fill = rgb(1, 1, 1, 0.5)
  ) +
  scale_fill_manual(
    values = c(
      "Background" = "grey90",
      "Bait" = pal_ostwald_disc[3],
      "Enriched" = pal_ostwald_disc[2],
      "TOR" = pal_ostwald_disc[4],
      "StringDB" = pal_ostwald_disc[1]
    )
  ) +
  scale_size_manual(
    values = c(
      "Background" = 1,
      "Bait" = 2,
      "Enriched" = 1,
      "TOR" = 2,
      "StringDB" = 1.5
    )
  ) +
  labs(
    x = "LogFC LST8-1 vs. GFP",
    y = "LogFC RAPTOR1 vs. GFP"
  ) +
  theme_leo() +
  theme(
    axis.title = element_text(),
    legend.title = element_blank(),
    legend.position = "none"
  ) +
  coord_cartesian(
    ylim = c(-5, 6),
    xlim = c(-5, 6)
  )

Nb_volc
```

## Table

```{r}
Nb_known <- Nb_volc_data |>
  filter(evidence %in% c("StringDB", "Bait", "TOR")) |>
  mutate(
    protein = str_replace(protein, "RAPTOR", bait_list$RAPTOR[1]),
    protein = str_replace(protein, "LST8", bait_list$LST8[1]),
  )

prot_names <- UniprotR::GetNamesTaxa(pull(Nb_known, protein))

Nb_table <- Nb_known |>
  left_join(prot_names, by = join_by("protein" == "Entry")) |>
  mutate(
    "Name" = str_remove_all(Protein.names, "\\(.+"),
    "LST8-1 logFC" = signs(LST8),
    "RAPTOR1 logFC" = signs(RAPTOR),
  ) |>
  select(
    "Symbol" = Gene.Names..primary.,
    Name,
    "LST8-1 logFC",
    "RAPTOR1 logFC"
  ) |>
  arrange(desc(Symbol))

tt(Nb_table)
# knitr::kable(
#   Nb_table,
#   "latex",
#   booktabs = TRUE
# ) |>
#   kableExtra::save_kable(
#     "test.pdf",
#     keep_tex = TRUE
#   )
```

# Load Arabidopsis PUP-IT data

```{r}
interactions <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE_PPI_FC_annotated.tsv"
  )
) |>
  group_by(batch, group1, group2, protein) |>
  # sort so we preferentially drop duplicates without annotations
  arrange(desc(Synonyms), .by_group = TRUE) |>
  # drop duplicated protein–gene matches
  distinct(protein, .keep_all = TRUE) |>
  ungroup()

inv <- interactions |>
  mutate(logFC = -logFC) |>
  rename(
    "group2" = "group1",
    "group1" = "group2"
  )


interactions <- interactions |>
  bind_rows(inv)

interactions
```

## Load control database

```{r}
ctrl_data <- read_tsv("data/output/control_data.tsv")

# n refers to the number of unrelated baits also putatively interacting with the respective protein
ctrl_data
```

# LST8/RAPTOR with constitutive FLAG::PUP (R0722)

## Load significant 35S interactions

```{r}
## Compare genotypes
R0722_ctrl <- interactions |>
  filter(logFC > 1 & adjPval < 0.05) |>
  filter(batch == c("R0722")) |>
  filter(
    group1 %in% c(
      "At_35S_RAPTOR_ctrl_24h",
      "At_35S_LST8_ctrl_24h"
    ) &
      group2 == "At_35S_GFP_ctrl_24h"
  )

R0722_suc <- interactions |>
  filter(logFC > 1 & adjPval < 0.05) |>
  filter(batch == c("R0722")) |>
  filter(
    group1 %in% c(
      "At_35S_RAPTOR_suc_24h",
      "At_35S_LST8_suc_24h"
    ) &
      group2 == "At_35S_GFP_suc_24h"
  )

## FKBP12 and rapamycin

R1017 <- interactions |>
  filter(logFC > 1 & adjPval < 0.05) |>
  filter(batch == c("R1017")) |>
  filter(
    group1 == "At_35S_FKBP12_rap_24h" &
      group2 == "At_35S_FKBP12_ctrl_24h"
  )

TORC_static <- rbind(R0722_ctrl, R0722_suc, R1017)

TORC_static
```

## Volcano plots

### Format data

```{r}
## Compare genotypes
R0722_raptor <- interactions |>
  filter(batch == c("R0722")) |>
  filter(
    group1 == "At_35S_RAPTOR_suc_24h" &
      group2 == "At_35S_GFP_suc_24h"
  ) |>
  mutate(bait = "RAPTOR")

R0722_lst8 <- interactions |>
  filter(batch == c("R0722")) |>
  filter(
    group1 == "At_35S_LST8_suc_24h" &
      group2 == "At_35S_GFP_suc_24h"
  ) |>
  mutate(bait = "LST8")

## FKBP12 and rapamycin
R1017 <- interactions |>
  filter(batch == c("R1017")) |>
  filter(
    group1 == "At_35S_FKBP12_rap_24h" &
      group2 == "At_35S_FKBP12_ctrl_24h"
  ) |>
  mutate(bait = "FKBP12")

TORC_static_full <- rbind(R0722_raptor, R0722_lst8, R1017)
```

### Plot graph

```{r}
const_volc <- function(list_counter) {
  data <- TORC_static_full |>
    filter(bait == names(bait_list)[list_counter]) |>
    left_join(
      db_list[[4]],
      by = join_by(protein == stringId_B)
    ) |>
    left_join(
      leene_data |> distinct(stringId, .keep_all = TRUE),
      by = join_by(
        protein == stringId
      )
    ) |>
    mutate(
      preferredName_B = case_when(
        str_detect(protein, bait_list[[list_counter]][1]) ~ bait_list[[list_counter]][2],
        !is.na(preferredName) ~ preferredName,
        TRUE ~ preferredName_B
      ),
      evidence = case_when(
        protein == bait_list[[list_counter]][1] ~ "Bait",
        !is.na(stringId_A) ~ "StringDB",
        !is.na(method) ~ "Van Leene et al., 2019",
        (logFC > 1) & (adjPval < 0.05) ~ "New",
        TRUE ~ "Background"
      ),
      evidence = ordered(
        evidence,
        levels = c(
          "Background",
          "New",
          "Van Leene et al., 2019",
          "StringDB",
          "Bait"
        )
      ),
      size = case_when(
        evidence == "Bait" ~ 1.5,
        evidence == "Van Leene et al., 2019" ~ 1.5,
        evidence == "StringDB" ~ 1.5,
        TRUE ~ 1
      ),
      sig = case_when(
        (logFC > 1) & (adjPval < 0.05) ~ 1,
        TRUE ~ 0.4
      )
    ) |>
    arrange(evidence)

  x_title_list <- c(
    "LogFC vs. GFP (+ sucrose)",
    "LogFC vs. GFP (+ sucrose)",
    "LogFC in response to rapamycin"
  )

  ggplot(
    data,
    aes(
      x = logFC,
      y = -log10(adjPval)
    )
  ) +
    geom_point(
      data = data,
      aes(
        fill = evidence,
        size = size,
        alpha = sig
      ),
      shape = 21,
      colour = "white",
      stroke = 0.2
    ) +
    geom_label_repel(
      data = filter(
        data,
        str_detect(protein, str_flatten(map(bait_list, 1), collapse = "|", na.rm = T)) &
          adjPval < 0.05 &
          logFC > 1
      ),
      aes(label = preferredName_B),
      label.size = NA,
      label.padding = unit(0.05, "lines"),
      fill = rgb(1, 1, 1, 0.5),
      family = "Helvetica",
      size = ggtext_size,
      min.segment.length = 0,
      linewidth = 0.2
    ) +
    scale_fill_manual(
      values = c(
        "Background" = "grey90",
        "Bait" = pal_ostwald_disc[3],
        "New" = pal_ostwald_disc[2],
        "StringDB" = pal_ostwald_disc[1],
        "Van Leene et al., 2019" = pal_ostwald_disc[4]
      ),
      drop = FALSE
    ) +
    scale_size_identity(
      guide = "none"
    ) +
    scale_alpha_identity(
      guide = "none"
    ) +
    scale_x_continuous(labels = signs_format()) +
    scale_y_continuous(labels = signs_format()) +
    labs(
      x = x_title_list[list_counter],
      y = "-log<sub>10</sub>(adj. *P*)"
    ) +
    theme_leo() +
    theme(
      axis.title.y = element_markdown(),
      axis.title.x = element_text(),
      legend.title = element_blank(),
      legend.justification = c(0, 0)
    ) +
    coord_fixed(
      xlim = c(-8, 8),
      ylim = c(0, 16)
    )
}

const_volc(1) +
  const_volc(2) + guides(fill = "none") +
  const_volc(3) + guides(fill = "none") +
  plot_layout(guides = "collect") &
  theme(legend.position = "bottom")

# ggsave(
#   "volcanos.pdf",
#   width = 180,
#   height = 80,
#   units = "mm"
# )
```

## LST/RAP vs GFP FC in suc vs man

### Format data

```{r}
R0722_man <- interactions |>
  filter(batch == c("R0722")) |>
  filter(
    group1 %in% c(
      "At_35S_LST8_ctrl_24h",
      "At_35S_RAPTOR_ctrl_24h"
    ) &
      group2 == "At_35S_GFP_ctrl_24h"
  )

R0722_suc <- interactions |>
  filter(batch == "R0722") |>
  filter(
    group1 %in% c(
      "At_35S_LST8_suc_24h",
      "At_35S_RAPTOR_suc_24h"
    ) &
      group2 == "At_35S_GFP_suc_24h"
  )

FC_treat_man <- R0722_man |>
  mutate(bait = case_when(
    str_detect(group1, "LST8") ~ "LST8",
    TRUE ~ "RAPTOR"
  )) |>
  dplyr::rename("man" = "logFC", "man_P" = "adjPval") |>
  select(protein, bait, man, man_P)

FC_treat_suc <- R0722_suc |>
  mutate(bait = case_when(
    str_detect(group1, "LST8") ~ "LST8",
    TRUE ~ "RAPTOR"
  )) |>
  dplyr::rename("suc" = "logFC", "suc_P" = "adjPval") |>
  select(protein, bait, suc, suc_P)

const_treat_data <- full_join(
  FC_treat_man,
  FC_treat_suc
)
```

### Plot graph

```{r}
FC_treat_scatter <- function(list_counter) {
  data <- const_treat_data |>
    filter(bait == names(bait_list)[list_counter]) |>
    left_join(
      db_list[[4]],
      by = join_by(protein == stringId_B)
    ) |>
    left_join(
      leene_data |> distinct(stringId, .keep_all = TRUE),
      by = join_by(
        protein == stringId
      )
    ) |>
    mutate(
      preferredName_B = case_when(
        str_detect(protein, bait_list[[list_counter]][1]) ~ bait_list[[list_counter]][2],
        !is.na(preferredName) ~ preferredName,
        TRUE ~ preferredName_B
      ),
      evidence = case_when(
        protein == bait_list[[list_counter]][1] ~ "Bait",
        !is.na(stringId_A) ~ "StringDB",
        !is.na(method) ~ "Van Leene et al., 2019",
        ((man > 1) & (man_P < 0.05) |
          (suc > 1) & (suc_P < 0.05)) ~ "New",
        TRUE ~ "Background"
      ),
      evidence = ordered(
        evidence,
        levels = c(
          "Background",
          "New",
          "Van Leene et al., 2019",
          "StringDB",
          "Bait"
        )
      ),
      size = case_when(
        evidence == "Bait" ~ 3,
        evidence == "Van Leene et al., 2019" ~ 1.5,
        evidence == "StringDB" ~ 1.5,
        TRUE ~ 1
      ),
      sig = case_when(
        ((man > 1) & (man_P < 0.05) |
          (suc > 1) & (suc_P < 0.05)) ~ 1,
        TRUE ~ 0.4
      )
    ) |>
    arrange(evidence)

  treat_dep <- data |>
    filter(
      (((man > 1) & (man_P < 0.05)) &
        ((suc < 1) | (suc_P > 0.05))) |
        (((suc > 1) & (suc_P < 0.05)) &
          ((man < 1) | (man_P > 0.05)))
    )
  total <- data |>
    filter(
      ((man > 1) & (man_P < 0.05) |
        (suc > 1) & (suc_P < 0.05))
    )

  ggplot(
    data,
    aes(
      x = man,
      y = suc
    )
  ) +
    geom_point(
      data = data,
      aes(
        fill = evidence,
        size = size,
        alpha = sig
      ),
      shape = 21,
      colour = "white",
      stroke = 0.2
    ) +
    geom_label_repel(
      data = filter(
        data,
        str_detect(protein, str_flatten(map(bait_list, 1), collapse = "|", na.rm = T)) &
          sig == 1
      ),
      aes(label = preferredName_B),
      min.segment.length = 0,
      linewidth = 0.2,
      label.size = NA,
      label.padding = unit(0.05, "lines"),
      fill = rgb(1, 1, 1, 0.5),
      family = "Helvetica",
      size = ggtext_size,
      nudge_x = 0.5,
      nudge_y = 0.5,
      hjust = 1
    ) +
    annotate(
      "richtext",
      label = paste0(
        round(nrow(treat_dep) / nrow(total) * 100, digits = 0),
        "% of interactors<br>are treatment-specific"
      ),
      hjust = 0,
      x = -5.9,
      y = -4.5,
      family = "Helvetica",
      size = ggtext_size,
      label.size = NA,
      fill = rgb(1, 1, 1, 0.5)
    ) +
    scale_fill_manual(
      values = c(
        "Background" = "grey75",
        "Bait" = pal_ostwald_disc[3],
        "New" = pal_ostwald_disc[2],
        "StringDB" = pal_ostwald_disc[1],
        "Van Leene et al., 2019" = pal_ostwald_disc[4]
      ),
      drop = FALSE
    ) +
    scale_size_identity(
      guide = "none"
    ) +
    scale_alpha_identity(
      guide = "none"
    ) +
    scale_x_continuous(labels = signs_format()) +
    scale_y_continuous(labels = signs_format()) +
    labs(
      # title = bait_list[[list_counter]][2],
      x = "LogFC vs. GFP (+ mannitol)",
      y = "LogFC vs. GFP (+ sucrose)"
    ) +
    theme_leo() +
    theme(
      axis.title.y = element_markdown(),
      axis.title.x = element_text(),
      legend.title = element_blank()
    ) +
    coord_fixed(
      xlim = c(-6, 6),
      ylim = c(-6, 6)
    )
}

FC_treat_scatter(1) + FC_treat_scatter(2) +
  plot_layout(guides = "collect") &
  theme(legend.position = "bottom")

# ggsave(
#   "2D_volcanos.pdf",
#   width = 140,
#   height = 80,
#   units = "mm"
# )
```

# LST8/RAPTOR with inducible FLAG::PUP (R0967)

## LST/RAP vs GFP FC in suc vs man

### Volcano plot

#### Format data

```{r}
R0967_raptor <- interactions |>
  filter(batch == c("R0967")) |>
  filter(
    group1 == "At_XVE_RAPTOR_suc_24h" &
      group2 == "At_XVE_GFP_suc_24h"
  ) |>
  mutate(bait = "RAPTOR")

R0967_lst8 <- interactions |>
  filter(batch == c("R0967")) |>
  filter(
    group1 == "At_XVE_LST8_suc_24h" &
      group2 == "At_XVE_GFP_suc_24h"
  ) |>
  mutate(bait = "LST8")

TORC_ind_full <- rbind(R0967_raptor, R0967_lst8)
```

#### Plot graph

```{r}
ind_volc <- function(list_counter) {
  data <- TORC_ind_full |>
    filter(bait == names(bait_list)[list_counter]) |>
    left_join(
      db_list[[4]],
      by = join_by(protein == stringId_B)
    ) |>
    left_join(
      leene_data |> distinct(stringId, .keep_all = TRUE),
      by = join_by(
        protein == stringId
      )
    ) |>
    mutate(
      preferredName_B = case_when(
        str_detect(protein, bait_list[[list_counter]][1]) ~ bait_list[[list_counter]][2],
        !is.na(preferredName) ~ preferredName,
        TRUE ~ preferredName_B
      ),
      evidence = case_when(
        protein == bait_list[[list_counter]][1] ~ "Bait",
        !is.na(stringId_A) ~ "StringDB",
        !is.na(method) ~ "Van Leene et al., 2019",
        (logFC > 1) & (adjPval < 0.05) ~ "New",
        TRUE ~ "Background"
      ),
      evidence = ordered(
        evidence,
        levels = c(
          "Background",
          "New",
          "Van Leene et al., 2019",
          "StringDB",
          "Bait"
        )
      ),
      size = case_when(
        evidence == "Bait" ~ 1.5,
        evidence == "Van Leene et al., 2019" ~ 1.5,
        evidence == "StringDB" ~ 1.5,
        TRUE ~ 1
      ),
      sig = case_when(
        (logFC > 1) & (adjPval < 0.05) ~ 1,
        TRUE ~ 0.4
      )
    ) |>
    arrange(evidence)

  ggplot(
    data,
    aes(
      x = logFC,
      y = -log10(adjPval)
    )
  ) +
    geom_point(
      data = data,
      aes(
        fill = evidence,
        size = size,
        alpha = sig
      ),
      shape = 21,
      colour = "white",
      stroke = 0.2
    ) +
    geom_label_repel(
      data = filter(
        data,
        str_detect(protein, str_flatten(map(bait_list, 1), collapse = "|", na.rm = T)) &
          adjPval < 0.05 &
          logFC > 1
      ),
      aes(label = preferredName_B),
      label.size = NA,
      label.padding = unit(0.05, "lines"),
      fill = rgb(1, 1, 1, 0.5),
      family = "Helvetica",
      size = ggtext_size,
      min.segment.length = 0,
      linewidth = 0.2
      # nudge_x = 0.25,
      # hjust = 0
    ) +
    scale_fill_manual(
      values = c(
        "Background" = "grey90",
        "Bait" = pal_ostwald_disc[3],
        "New" = pal_ostwald_disc[2],
        "StringDB" = pal_ostwald_disc[1],
        "Van Leene et al., 2019" = pal_ostwald_disc[4]
      ),
      drop = FALSE
    ) +
    scale_size_identity(
      guide = "none"
    ) +
    scale_alpha_identity(
      guide = "none"
    ) +
    scale_x_continuous(labels = signs_format()) +
    scale_y_continuous(labels = signs_format()) +
    labs(
      # title = bait_list[[list_counter]][2],
      x = "LogFC vs. GFP (+ sucrose)",
      y = "-log<sub>10</sub>(adj. *P*)"
    ) +
    theme_leo() +
    theme(
      axis.title.y = element_markdown(),
      axis.title.x = element_text(),
      legend.title = element_blank(),
      legend.justification = c(0, 0)
    ) +
    coord_cartesian(
      xlim = c(-6, 6),
      ylim = c(0, 35)
    )
}

ind_volc(1) + ind_volc(2)
```

### 2D volcano

#### Format data

```{r}
R0967_man <- interactions |>
  filter(batch == c("R0967")) |>
  filter(
    group1 %in% c(
      "At_XVE_LST8_man_24h",
      "At_XVE_RAPTOR_man_24h",
      "At_XVE_LST8_man_4h",
      "At_XVE_RAPTOR_man_4h"
    ) &
      group2 %in% c(
        "At_XVE_GFP_man_24h",
        "At_XVE_GFP_man_4h"
      )
  ) |>
  filter(str_extract(group1, "_[:digit:]+h") == str_extract(group2, "_[:digit:]+h"))

R0967_suc <- interactions |>
  filter(batch == "R0967") |>
  filter(
    group1 %in% c(
      "At_XVE_LST8_suc_24h",
      "At_XVE_RAPTOR_suc_24h",
      "At_XVE_LST8_suc_4h",
      "At_XVE_RAPTOR_suc_4h"
    ) &
      group2 %in% c(
        "At_XVE_GFP_suc_24h",
        "At_XVE_GFP_suc_4h"
      )
  ) |>
  filter(str_extract(group1, "_[:digit:]+h") == str_extract(group2, "_[:digit:]+h"))

FC_treat_man <- R0967_man |>
  mutate(bait = case_when(
    str_detect(group1, "LST8") ~ "LST8",
    TRUE ~ "RAPTOR"
  )) |>
  dplyr::rename("man" = "logFC", "man_P" = "adjPval") |>
  mutate(time = str_extract(group1, "_[:digit:]+h")) |>
  select(protein, bait, time, man, man_P)

FC_treat_suc <- R0967_suc |>
  mutate(bait = case_when(
    str_detect(group1, "LST8") ~ "LST8",
    TRUE ~ "RAPTOR"
  )) |>
  dplyr::rename("suc" = "logFC", "suc_P" = "adjPval") |>
  mutate(time = str_extract(group1, "_[:digit:]+h")) |>
  select(protein, bait, time, suc, suc_P)

ind_treat_data <- full_join(FC_treat_man, FC_treat_suc)
```

#### Plot graph

```{r}
ind_treat_scatter <- function(list_counter, t) {
  data <- ind_treat_data |>
    filter(bait == names(bait_list)[list_counter]) |>
    filter(time == t) |>
    left_join(
      db_list[[4]],
      by = join_by(protein == stringId_B)
    ) |>
    left_join(
      leene_data |> distinct(stringId, .keep_all = TRUE),
      by = join_by(
        protein == stringId
      )
    ) |>
    mutate(
      preferredName_B = case_when(
        str_detect(protein, bait_list[[list_counter]][1]) ~ bait_list[[list_counter]][2],
        !is.na(preferredName) ~ preferredName,
        TRUE ~ preferredName_B
      ),
      evidence = case_when(
        protein == bait_list[[list_counter]][1] ~ "Bait",
        !is.na(stringId_A) ~ "StringDB",
        !is.na(method) ~ "Van Leene et al., 2019",
        ((man > 1) & (man_P < 0.05) |
          (suc > 1) & (suc_P < 0.05)) ~ "New",
        TRUE ~ "Background"
      ),
      evidence = ordered(
        evidence,
        levels = c(
          "Background",
          "New",
          "Van Leene et al., 2019",
          "StringDB",
          "Bait"
        )
      ),
      size = case_when(
        evidence == "Bait" ~ 1.5,
        evidence == "Van Leene et al., 2019" ~ 1.5,
        evidence == "StringDB" ~ 1.5,
        TRUE ~ 1
      ),
      sig = case_when(
        ((man > 1) & (man_P < 0.05) |
          (suc > 1) & (suc_P < 0.05)) ~ 1,
        TRUE ~ 0.4
      )
    ) |>
    arrange(evidence)

  treat_dep <- data |>
    filter(
      (((man > 1) & (man_P < 0.05)) &
        ((suc < 1) | (suc_P > 0.05))) |
        (((suc > 1) & (suc_P < 0.05)) &
          ((man < 1) | (man_P > 0.05)))
    )
  total <- data |>
    filter(
      ((man > 1) & (man_P < 0.05)) |
        ((suc > 1) & (suc_P < 0.05))
    )

  ggplot(
    data,
    aes(
      x = man,
      y = suc
    )
  ) +
    geom_point(
      data = data,
      aes(
        fill = evidence,
        size = size,
        alpha = sig
      ),
      shape = 21,
      colour = "white",
      stroke = 0.2
    ) +
    geom_label_repel(
      data = filter(
        data,
        str_detect(protein, str_flatten(map(bait_list, 1), collapse = "|", na.rm = T)) &
          sig == 1
      ),
      aes(label = preferredName_B),
      min.segment.length = 0,
      linewidth = 0.2,
      label.size = NA,
      label.padding = unit(0.05, "lines"),
      fill = rgb(1, 1, 1, 0.5),
      family = "Helvetica",
      size = ggtext_size,
      nudge_x = 0.25,
      hjust = 0
    ) +
    annotate(
      "richtext",
      label = paste0(
        round(nrow(treat_dep) / nrow(total) * 100, digits = 0),
        "% of interactors<br>are treatment-specific"
      ),
      hjust = 0,
      x = -5.9,
      y = -4.5,
      family = "Helvetica",
      size = ggtext_size,
      label.size = NA,
      fill = rgb(1, 1, 1, 0.5)
    ) +
    scale_fill_manual(
      values = c(
        "Background" = "grey75",
        "Bait" = pal_ostwald_disc[3],
        "New" = pal_ostwald_disc[2],
        "StringDB" = pal_ostwald_disc[1],
        "Van Leene et al., 2019" = pal_ostwald_disc[4]
      ),
      drop = FALSE
    ) +
    scale_size_identity(
      guide = "none"
    ) +
    scale_alpha_identity(
      guide = "none"
    ) +
    scale_x_continuous(labels = signs_format()) +
    scale_y_continuous(labels = signs_format()) +
    labs(
      x = "LogFC vs. GFP (+ mannitol)",
      y = "LogFC vs. GFP (+ sucrose)"
    ) +
    theme_leo() +
    theme(
      axis.title.y = element_markdown(),
      axis.title.x = element_text(),
      legend.title = element_blank()
    ) +
    coord_fixed(
      xlim = c(-6, 6),
      ylim = c(-6, 6)
    )
}

ind_treat_scatter(1, "_24h") + ind_treat_scatter(2, "_24h") +
  plot_layout(guides = "collect", nrow = 1) &
  theme(legend.position = "bottom")

# ggsave(
#   "2D_volcano_R0967.pdf",
#   width = 180,
#   height = 80,
#   units = "mm"
# )
```

#  Upset plot of experiments/baits

## By experiment — analogous to the network

### Format data

```{r}
upset_data <- interactions |>
  filter(logFC > 1 & adjPval < 0.05) |>
  separate_wider_delim(
    group1,
    "_",
    names = c(
      "species1",
      "construct1",
      "bait1",
      "treatment1",
      "time1"
    ),
    cols_remove = FALSE
  ) |>
  separate_wider_delim(
    group2,
    "_",
    names = c(
      "species2",
      "construct2",
      "bait2",
      "treatment2",
      "time2"
    ),
    cols_remove = FALSE
  ) |>
  filter(
    (treatment1 == treatment2 & time1 == time2) | # compare baits
      (bait1 == bait2 & time1 == time2) | # compare treatments
      (treatment1 == treatment2 & bait1 == bait2) # compare time points
  ) |>
  filter(
    bait1 != "GFP"
  ) |>
  mutate(
    batch = case_when(
      batch == "R0722" ~ "35S",
      batch == "R0967" ~ "XVE",
      batch == "R1017" ~ "35S",
      batch == "R1067" ~ "XVE~TiO~"
    ),
    biorep = paste(batch, bait1, sep = " ")
  ) |>
  select(protein, c(21:28)) |>
  distinct() |>
  mutate(present = 1) |>
  pivot_wider(
    names_from = biorep,
    values_from = present,
    values_fill = FALSE
  )
```

### Plot Upset

```{r}
groups <- names(upset_data)[9:15]

upset(
  upset_data,
  groups,
  name = "Experiment",
  min_size = 20,
  set_sizes = FALSE,
  sort_sets = FALSE,
  base_annotations = list(
    "Intersection size" = intersection_size(
      text = list("family" = "Helvetica", "size" = ggtext_size)
    )
  )
) &
  theme_leo() &
  theme(
    axis.text.x = element_blank(),
    axis.text.y = element_markdown()
  )

# ggsave(
#   "upset.pdf",
#   width = twocol,
#   height = onecol
# )
```

## By bait and treatment

### Load data

```{r}
upset_data <- interactions |>
  filter(logFC > 1 & adjPval < 0.05) |>
  separate_wider_delim(
    group1,
    "_",
    names = c(
      "species1",
      "construct1",
      "bait1",
      "treatment1",
      "time1"
    ),
    cols_remove = FALSE
  ) |>
  separate_wider_delim(
    group2,
    "_",
    names = c(
      "species2",
      "construct2",
      "bait2",
      "treatment2",
      "time2"
    ),
    cols_remove = FALSE
  ) |>
  mutate(
    treatment1 = case_when(
      bait1 %in% c("RAPTOR", "LST8") & treatment1 == "ctrl" ~ "man",
      TRUE ~ treatment1
    ),
    treatment2 = case_when(
      bait1 %in% c("RAPTOR", "LST8") & treatment2 == "ctrl" ~ "man",
      TRUE ~ treatment2
    )
  ) |>
  filter(
    (treatment1 == treatment2 & time1 == time2) |
      (bait1 == "FKBP12" & time1 == time2) # compare baits
  ) |>
  filter(
    bait2 %in% c("GFP", "FKBP12")
  ) |>
  mutate(
    bait1 = str_replace(bait1, "FKBP12", "ScFKBP"),
    bait1 = str_replace(bait1, "LST8", "LST8-1"),
    bait1 = str_replace(bait1, "RAPTOR", "RAPTOR1"),
    biorep = paste0(bait1, " ", treatment1, "."),
    evidence = case_when(
      protein %in% TORC_db$stringId_B ~ "StringDB",
      protein %in% leene_proteins ~ "Van Leene et al., 2019",
      TRUE ~ "New"
    )
  ) |>
  select(protein, c(21:29)) |>
  distinct() |>
  mutate(present = 1) |>
  pivot_wider(
    names_from = biorep,
    values_from = present,
    values_fill = FALSE
  )
```

### Plot Upset

```{r}
groups <- names(upset_data)[10:15]

upset_baits <- upset(
  upset_data,
  groups,
  name = "Bait and condition",
  min_size = 20,
  set_sizes = FALSE,
  sort_sets = FALSE,
  height_ratio = 1,
  stripes = "white",
  base_annotations = list(
    "Intersection size" = intersection_size(
      text = list("family" = "Helvetica", "size" = ggtext_size),
      mapping = aes(fill = evidence)
    ) +
      scale_fill_manual(values = pal_ostwald_disc[c(2, 1, 4)]) +
      scale_y_continuous(expand = expansion(mult = c(0, 0.05)))
  ),
  matrix = (
    intersection_matrix(
      geom = geom_point(
        shape = "square",
        size = 1,
      ),
      outline_color = list(
        active = "black",
        inactive = "grey90"
      )
    )
    + scale_color_manual(
        values = c("TRUE" = "black", "FALSE" = "grey90"),
        guide = "none"
      )
  )
) &
  # coord_cartesian(expand = FALSE) &
  theme_leo() &
  theme(
    axis.text.x = element_blank(),
    axis.text.y = element_markdown(),
    legend.title = element_blank(),
    legend.key.height = unit(2, "mm"),
    legend.key.width = unit(2, "mm"),
    legend.position = c(1, 1),
    legend.justification = c(1, 1)
  )

upset_baits

# ggsave(
#   "upset_baits.pdf",
#   width = twocol,
#   height = onecol
# )
```

## 35S vs XVE

### Load data

```{r}
upset_data <- interactions |>
  filter(batch %in% c("R0722", "R0967")) |>
  filter(logFC > 1 & adjPval < 0.05) |>
  separate_wider_delim(
    group1,
    "_",
    names = c(
      "species1",
      "construct1",
      "bait1",
      "treatment1",
      "time1"
    ),
    cols_remove = FALSE
  ) |>
  separate_wider_delim(
    group2,
    "_",
    names = c(
      "species2",
      "construct2",
      "bait2",
      "treatment2",
      "time2"
    ),
    cols_remove = FALSE
  ) |>
  mutate(
    treatment1 = case_when(
      bait1 %in% c("RAPTOR", "LST8") & treatment1 == "ctrl" ~ "man",
      TRUE ~ treatment1
    ),
    treatment2 = case_when(
      bait1 %in% c("RAPTOR", "LST8") & treatment2 == "ctrl" ~ "man",
      TRUE ~ treatment2
    )
  ) |>
  filter(
    treatment1 == treatment2 & time1 == time2 # compare baits
  ) |>
  filter(
    bait2 == "GFP"
  ) |>
  mutate(
    batch = case_when(
      batch == "R0722" ~ "35S",
      batch == "R0967" ~ "XVE"
    ),
    bait1 = str_replace(bait1, "LST8", "LST8-1"),
    bait1 = str_replace(bait1, "RAPTOR", "RAPTOR1"),
    biorep = paste0(batch, " ", bait1, " ", treatment1, "."),
    evidence = case_when(
      protein %in% TORC_db$stringId_B ~ "StringDB",
      protein %in% leene_proteins ~ "Van Leene et al., 2019",
      TRUE ~ "New"
    )
  ) |>
  select(protein, c(21:29)) |>
  distinct() |>
  mutate(present = 1) |>
  pivot_wider(
    names_from = biorep,
    values_from = present,
    values_fill = FALSE
  )

n_35S <- upset_data |>
  filter(`35S LST8-1 suc.` == 1 | `35S LST8-1 man.` == 1 | `35S RAPTOR1 suc.` == 1 | `35S RAPTOR1 man.` == 1) |>
  distinct(protein) |>
  nrow()

n_known_35S <- upset_data |>
  filter(`35S LST8-1 suc.` == 1 | `35S LST8-1 man.` == 1 | `35S RAPTOR1 suc.` == 1 | `35S RAPTOR1 man.` == 1) |>
  filter(evidence %in% c("StringDB", "Van Leene et al., 2019")) |>
  distinct(protein) |>
  nrow()

n_across_baits_35S <- upset_data |>
  filter((`35S LST8-1 suc.` == 1 | `35S LST8-1 man.` == 1) & (`35S RAPTOR1 suc.` == 1 | `35S RAPTOR1 man.` == 1)) |>
  distinct(protein) |>
  nrow()

n_across_treatments_35S <- upset_data |>
  filter((`35S LST8-1 suc.` == 1 | `35S RAPTOR1 suc.` == 1) & (`35S LST8-1 man.` == 1 | `35S RAPTOR1 man.` == 1)) |>
  distinct(protein) |>
  nrow()

n_XVE <- upset_data |>
  filter(`XVE LST8-1 suc.` == 1 | `XVE LST8-1 man.` == 1 | `XVE RAPTOR1 suc.` == 1 | `XVE RAPTOR1 man.` == 1) |>
  distinct(protein) |>
  nrow()

n_known_XVE <- upset_data |>
  filter(`XVE LST8-1 suc.` == 1 | `XVE LST8-1 man.` == 1 | `XVE RAPTOR1 suc.` == 1 | `XVE RAPTOR1 man.` == 1) |>
  filter(evidence %in% c("StringDB", "Van Leene et al., 2019")) |>
  distinct(protein) |>
  nrow()

n_across_baits_XVE <- upset_data |>
  filter((`XVE LST8-1 suc.` == 1 | `XVE LST8-1 man.` == 1) & (`XVE RAPTOR1 suc.` == 1 | `XVE RAPTOR1 man.` == 1)) |>
  distinct(protein) |>
  nrow()

n_across_treatments_XVE <- upset_data |>
  filter((`XVE LST8-1 suc.` == 1 | `XVE RAPTOR1 suc.` == 1) & (`XVE LST8-1 man.` == 1 | `XVE RAPTOR1 man.` == 1)) |>
  distinct(protein) |>
  nrow()

cat(
  paste0(
    "35S: ", n_known_35S, " known interactors; ",
    n_across_baits_35S, " interactors out of ", n_35S, " total interactors found in both baits (", round((n_across_baits_35S / n_35S) * 100, digits = 0), "%); ",
    n_across_treatments_35S, " interactors out of ", n_35S, " total interactors found in both treatments (", round((n_across_treatments_35S / n_35S) * 100, digits = 0), "%)."
  )
)

cat(
  paste0(
    "XVE: ", n_known_XVE, " known interactors; ",
    n_across_baits_XVE, " interactors out of ", n_XVE, " total interactors found in both baits (", round((n_across_baits_XVE / n_XVE) * 100, digits = 0), "%); ",
    n_across_treatments_XVE, " interactors out of ", n_XVE, " total interactors found in both treatments (", round((n_across_treatments_XVE / n_XVE) * 100, digits = 0), "%)."
  )
)
```

### Plot Upset

```{r}
groups <- names(upset_data)[10:17]

upset_constructs <- upset(
  upset_data,
  groups,
  name = "Bait and condition",
  min_size = 20,
  keep_empty_groups = TRUE,
  set_sizes = FALSE,
  sort_sets = FALSE,
  height_ratio = 1,
  stripes = "white",
  base_annotations = list(
    "Intersection size" = intersection_size(
      text = list("family" = "Helvetica", "size" = ggtext_size),
      mapping = aes(fill = evidence)
    ) +
      scale_fill_manual(values = pal_ostwald_disc[c(2, 1, 4)]) +
      scale_y_continuous(expand = expansion(mult = c(0, 0.05)))
  ),
  matrix = (
    intersection_matrix(
      geom = geom_point(
        shape = "square",
        size = 1,
      ),
      outline_color = list(
        active = "black",
        inactive = "grey90"
      )
    )
    + scale_color_manual(
        values = c("TRUE" = "black", "FALSE" = "grey90"),
        guide = "none"
      )
  )
) &
  # coord_cartesian(expand = FALSE) &
  theme_leo() &
  theme(
    axis.text.x = element_blank(),
    axis.text.y = element_markdown(),
    legend.title = element_blank(),
    legend.key.height = unit(2, "mm"),
    legend.key.width = unit(2, "mm"),
    legend.position = c(1, 1),
    legend.justification = c(1, 1)
  )

upset_constructs

# ggsave(
#   "upset_constructs.pdf",
#   width = twocol,
#   height = onecol
# )
```


# Venn diagram 35S vs XVE

## Format data

```{r}
venn_data <- upset_data <- interactions |>
  filter(batch %in% c("R0722", "R0967")) |>
  filter(logFC > 1 & adjPval < 0.05) |>
  separate_wider_delim(
    group1,
    "_",
    names = c(
      "species1",
      "construct1",
      "bait1",
      "treatment1",
      "time1"
    ),
    cols_remove = FALSE
  ) |>
  separate_wider_delim(
    group2,
    "_",
    names = c(
      "species2",
      "construct2",
      "bait2",
      "treatment2",
      "time2"
    ),
    cols_remove = FALSE
  ) |>
  mutate(
    treatment1 = case_when(
      bait1 %in% c("RAPTOR", "LST8") & treatment1 == "ctrl" ~ "man",
      TRUE ~ treatment1
    ),
    treatment2 = case_when(
      bait1 %in% c("RAPTOR", "LST8") & treatment2 == "ctrl" ~ "man",
      TRUE ~ treatment2
    )
  ) |>
  filter(
    treatment1 == treatment2 & time1 == time2 # compare baits
  ) |>
  filter(
    bait2 == "GFP"
  ) |>
  mutate(
    batch = case_when(
      batch == "R0722" ~ "35S",
      batch == "R0967" ~ "XVE"
    ),
    bait1 = str_replace(bait1, "LST8", "LST8-1"),
    bait1 = str_replace(bait1, "RAPTOR", "RAPTOR1"),
    biorep = paste0(batch, " ", bait1, " ", treatment1, "."),
    evidence = case_when(
      protein %in% TORC_db$stringId_B ~ "StringDB",
      protein %in% leene_proteins ~ "Van Leene et al., 2019",
      TRUE ~ "New"
    )
  )

venn_data_suc <- venn_data |>
  filter(treatment1 == "suc") |>
  select(protein, biorep) |>
  distinct() |>
  mutate(present = 1) |>
  pivot_wider(
    names_from = biorep,
    values_from = present,
    values_fill = FALSE
  ) |>
  select(-protein)

venn_data_man <- venn_data |>
  filter(treatment1 == "man") |>
  select(protein, biorep) |>
  distinct() |>
  mutate(present = 1) |>
  pivot_wider(
    names_from = biorep,
    values_from = present,
    values_fill = FALSE
  ) |>
  select(-protein)
```


## Plot diagram

```{r}
## Sucrose
euler_overlaps <- euler(
  venn_data_suc,
  shape = "ellipse"
)

euler_plot <- plot(
  euler_overlaps,
  quantities = list(fontfamily = "Helvetica", fontsize = text_size),
  labels = list(fontfamily = "Helvetica", fontsize = text_size)
)

# pdf("venn_35S_suc.pdf", width = onecol, height = onecol)
euler_plot
# dev.off()

## Mannitol
euler_overlaps <- euler(
  venn_data_man,
  shape = "ellipse"
)

suc_man_euler_plot <- plot(
  euler_overlaps,
  quantities = list(fontfamily = "Helvetica", fontsize = text_size),
  labels = list(fontfamily = "Helvetica", fontsize = text_size)
)

# pdf("venn_35S_man.pdf", width = onecol, height = onecol)
suc_man_euler_plot
# dev.off()
```


# Venn diagram with Van Leene 2019

## Format data

```{r}
leene_tap <- leene_data |>
  filter(method == "TAP-MS") |>
  pull(stringId)

leene_pd <- leene_data |>
  filter(method == "Pull-Down") |>
  pull(stringId)

core <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE/Q93YQ1_Q9LV27_P20081_min-5_ctrl-FALSE_GFP-TRUE_exclusive-FALSE_table.tsv"
  )
) |>
  distinct(protein) |>
  drop_na() |>
  pull(protein)

wider <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE/Q93YQ1_Q9LV27_P20081_min-3_ctrl-FALSE_GFP-TRUE_exclusive-FALSE_table.tsv"
  )
) |>
  distinct(protein) |>
  drop_na() |>
  pull(protein)

widest <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE/Q93YQ1_Q9LV27_P20081_min-2_ctrl-FALSE_GFP-FALSE_exclusive-FALSE_table.tsv"
  )
) |>
  distinct(protein) |>
  drop_na() |>
  pull(protein)

overlaps <- data.frame(
  protein = c(core, wider, widest, leene_tap, leene_pd)
) |>
  distinct(protein) |>
  mutate(
    "Core" = case_when(
      protein %in% core ~ TRUE,
      TRUE ~ FALSE
    ),
    "Wider" = case_when(
      protein %in% wider ~ TRUE,
      TRUE ~ FALSE
    ),
    "Widest" = case_when(
      protein %in% widest ~ TRUE,
      TRUE ~ FALSE
    ),
    "TAP-MS" = case_when(
      protein %in% leene_tap ~ TRUE,
      TRUE ~ FALSE
    ),
    "Pull-Down" = case_when(
      protein %in% leene_pd ~ TRUE,
      TRUE ~ FALSE
    )
  ) |>
  select(-protein)
```


## Plot diagram

```{r}
euler_overlaps <- euler(
  overlaps,
  shape = "ellipse"
)

euler_plot <- plot(
  euler_overlaps,
  quantities = list(fontfamily = "Helvetica", fontsize = text_size),
  # edges = list(lty = 2),
  labels = list(fontfamily = "Helvetica", fontsize = text_size),
  legend = list(
    labels = c(
      "This study",
      "This study",
      "This study",
      "Leene et al., 2019",
      "Leene et al., 2019"
    ),
    fontfamily = "Helvetica",
    fontsize = text_size
  ),
  fill = c(
    colorspace::lighten(pal_ostwald_disc[2], 0),
    colorspace::lighten(pal_ostwald_disc[2], 0.3),
    colorspace::lighten(pal_ostwald_disc[2], 0.6),
    pal_ostwald_disc[c(1, 4)]
  )
)

# pdf("venn_leene.pdf", width = twocol * 1.2, height = onecol * 1.2)
euler_plot
# dev.off()
```

# Venn diagram with seedling/culture data

## Format data

```{r}
seedling <- leene_data |>
  filter(seedling == 1) |>
  pull(stringId) |>
  unique()

culture <- leene_data |>
  filter(culture == 1) |>
  pull(stringId) |>
  unique()

overlaps <- data.frame(
  protein = c(core, wider, widest, seedling, culture)
) |>
  distinct(protein) |>
  mutate(
    "Core" = case_when(
      protein %in% core ~ TRUE,
      TRUE ~ FALSE
    ),
    "Wider" = case_when(
      protein %in% wider ~ TRUE,
      TRUE ~ FALSE
    ),
    "Widest" = case_when(
      protein %in% widest ~ TRUE,
      TRUE ~ FALSE
    ),
    "Seedlings" = case_when(
      protein %in% seedling ~ TRUE,
      TRUE ~ FALSE
    ),
    "Cell culture" = case_when(
      protein %in% culture ~ TRUE,
      TRUE ~ FALSE
    ),
  ) |>
  select(-protein)

# counts only TAP-MS, hence the difference to the Venn values (16 vs 18 in the 'both' category)
seedling_counts <- leene_data |>
  distinct() |>
  summarise(
    "both" = sum(method == "TAP-MS" & seedling == 1 & culture == 1),
    "culture" = sum(method == "TAP-MS" & seedling == 0 & culture == 1),
    "seedling" = sum(method == "TAP-MS" & seedling == 1 & culture == 0)
  )
```

## Plot diagram

```{r}
euler_overlaps <- euler(
  overlaps,
  shape = "ellipse"
)

euler_plot <- plot(
  euler_overlaps,
  quantities = list(fontfamily = "Helvetica", fontsize = text_size),
  labels = list(fontfamily = "Helvetica", fontsize = text_size),
  legend = list(
    labels = c(
      "This study",
      "This study",
      "This study",
      "Leene et al., 2019",
      "Leene et al., 2019"
    ),
    fontfamily = "Helvetica",
    fontsize = text_size
  ),
  fill = c(
    colorspace::lighten(pal_ostwald_disc[2], 0),
    colorspace::lighten(pal_ostwald_disc[2], 0.3),
    colorspace::lighten(pal_ostwald_disc[2], 0.6),
    pal_ostwald_disc[c(1, 4)]
  )
)

# pdf("venn_seedlings.pdf", width = twocol * 1.2, height = onecol * 1.2)
euler_plot
# dev.off()
```

# Venn diagram with method-specific bait overlap 

## Format data

```{r}
tap_plant <- leene_data |>
  separate_longer_delim(bait, delim = "/") |>
  rename("protein" = stringId) |>
  filter(method == "TAP-MS" & seedling == 1) |>
  group_by(protein) |>
  summarise(
    "LST8-1" = "LST8" %in% bait,
    "RAPTOR1" = "RAPTOR1" %in% bait
    # "TOR" = "TOR" %in% bait
  ) |>
  ungroup() |>
  select(-protein)

tap_cell <- leene_data |>
  separate_longer_delim(bait, delim = "/") |>
  rename("protein" = stringId) |>
  filter(method == "TAP-MS" & culture == 1) |>
  group_by(protein) |>
  summarise(
    "LST8-1" = "LST8" %in% bait,
    "RAPTOR1" = "RAPTOR1" %in% bait
  ) |>
  ungroup() |>
  select(-protein)

pd_cell <- leene_data |>
  separate_longer_delim(bait, delim = "/") |>
  rename("protein" = stringId) |>
  filter(method == "Pull-Down" & culture == 1) |>
  group_by(protein) |>
  summarise(
    "LST8-1" = "LST8" %in% bait,
    "RAPTOR1" = "RAPTOR1" %in% bait
  ) |>
  ungroup() |>
  select(-protein)

turbo_cell <- persyn_data |>
  filter(method == "TurboID") |>
  separate_longer_delim(bait, delim = "/") |>
  rename("protein" = stringId) |>
  group_by(protein) |>
  summarise(
    "LST8-1" = "LST8-1" %in% bait,
    "RAPTOR1" = "RAPTOR1B" %in% bait
  ) |>
  ungroup() |>
  select(-protein)

pup_plant <- interactions |>
  filter(logFC > 1 & adjPval < 0.05) |>
  filter(batch %in% c(
    "R0722",
    "R1017",
    "R0967"
  )) |>
  separate_wider_delim(
    group1,
    names = c("bait_species", "bait_construct", "bait_protein", "bait_treatment", "bait_time"),
    delim = "_",
    cols_remove = FALSE
  ) |>
  separate_wider_delim(
    group2,
    names = c("control_species", "control_construct", "control_protein", "control_treatment", "control_time"),
    delim = "_",
    cols_remove = FALSE
  ) |>
  filter(
    (bait_treatment == control_treatment & bait_time == control_time & bait_protein != "GFP" & control_protein == "GFP") | # compare baits
      (bait_protein == "FKBP12" & bait_time == control_time & bait_treatment == "rap") # add ScFKBP
  ) |>
  group_by(protein) |>
  summarise(
    "LST8-1" = "LST8" %in% bait_protein,
    "RAPTOR1" = "RAPTOR" %in% bait_protein
    # "ScFKBP" = "FKBP12" %in% bait_protein
  ) |>
  ungroup() |>
  select(-protein)

pup_cell <- Nb_interactions |>
  filter(logFC > 1 & adjPval < 0.05) |>
  separate_wider_delim(
    group1,
    names = c("bait_species", "bait_construct", "bait_protein"),
    delim = "_",
    cols_remove = FALSE
  ) |>
  separate_wider_delim(
    group2,
    names = c("control_species", "control_construct", "control_protein"),
    delim = "_",
    cols_remove = FALSE
  ) |>
  filter(
    (bait_protein != "GFP" & control_protein == "GFP")
  ) |>
  group_by(protein) |>
  summarise(
    "LST8-1" = "LST8" %in% bait_protein,
    "RAPTOR1" = "RAPTOR" %in% bait_protein
  ) |>
  ungroup() |>
  select(-protein)
```

## Plot Venn diagrams

```{r}
tap_plant_overlaps <- euler(
  tap_plant,
  shape = "ellipse"
)

tap_plant_plot <- plot(
  tap_plant_overlaps,
  quantities = list(fontfamily = "Helvetica", fontsize = text_size),
  labels = FALSE,
  fill = c(
    colorspace::lighten(pal_ostwald_disc[2], 0),
    colorspace::lighten(pal_ostwald_disc[2], 0.6)
  )
)

tap_cell_overlaps <- euler(
  tap_cell,
  shape = "ellipse"
)

tap_cell_plot <- plot(
  tap_cell_overlaps,
  quantities = list(fontfamily = "Helvetica", fontsize = text_size),
  labels = FALSE,
  fill = c(
    colorspace::lighten(pal_ostwald_disc[2], 0),
    colorspace::lighten(pal_ostwald_disc[2], 0.6)
  )
)

pd_cell_overlaps <- euler(
  pd_cell,
  shape = "ellipse"
)

pd_cell_plot <- plot(
  pd_cell_overlaps,
  quantities = list(fontfamily = "Helvetica", fontsize = text_size),
  labels = FALSE,
  fill = c(
    colorspace::lighten(pal_ostwald_disc[2], 0),
    colorspace::lighten(pal_ostwald_disc[2], 0.6)
  )
)

turbo_cell_overlaps <- euler(
  turbo_cell,
  shape = "ellipse"
)

turbo_cell_plot <- plot(
  turbo_cell_overlaps,
  quantities = list(fontfamily = "Helvetica", fontsize = text_size),
  labels = FALSE,
  fill = c(
    colorspace::lighten(pal_ostwald_disc[2], 0),
    colorspace::lighten(pal_ostwald_disc[2], 0.6)
  )
)

pup_plant_overlaps <- euler(
  pup_plant,
  shape = "ellipse"
)

pup_plant_plot <- plot(
  pup_plant_overlaps,
  quantities = list(fontfamily = "Helvetica", fontsize = text_size),
  labels = FALSE,
  fill = c(
    colorspace::lighten(pal_ostwald_disc[2], 0),
    colorspace::lighten(pal_ostwald_disc[2], 0.6)
  )
)

pup_cell_overlaps <- euler(
  pup_cell,
  shape = "ellipse"
)

pup_cell_plot <- plot(
  pup_cell_overlaps,
  quantities = list(fontfamily = "Helvetica", fontsize = text_size),
  labels = FALSE,
  fill = c(
    colorspace::lighten(pal_ostwald_disc[2], 0),
    colorspace::lighten(pal_ostwald_disc[2], 0.6)
  )
)

# pdf("tap_cell.pdf", width = sqrt(nrow(tap_cell)) / 10, height = sqrt(nrow(tap_cell)) / 10)
tap_cell_plot
# dev.off()
#
# pdf("tap_plant.pdf", width = sqrt(nrow(tap_plant)) / 10, height = sqrt(nrow(tap_plant)) / 10)
tap_plant_plot
# dev.off()
#
# pdf("pd_cell.pdf", width = sqrt(nrow(pd_cell)) / 10, height = sqrt(nrow(pd_cell)) / 10)
pd_cell_plot
# dev.off()
#
# pdf("turbo_cell.pdf", width = sqrt(nrow(turbo_cell)) / 10, height = sqrt(nrow(turbo_cell)) / 10)
turbo_cell_plot
# dev.off()
#
# pdf("pup_cell.pdf", width = sqrt(nrow(pup_cell)) / 10, height = sqrt(nrow(pup_cell)) / 10)
pup_cell_plot
# dev.off()
#
# pdf("pup_plant.pdf", width = sqrt(nrow(pup_plant)) / 10, height = sqrt(nrow(pup_plant)) / 10)
pup_plant_plot
# dev.off()
```

## Plot total number

```{r}
plant_quant <- tibble(
  "method" = rep(c("TAP", "PUP-IT"), each = 2),
  "bait" = rep(c("LST8-1", "RAPTOR1"), 2),
  "count" = c(
    filter(tap_plant, `LST8-1` == TRUE) |> nrow(),
    filter(tap_plant, RAPTOR1 == TRUE) |> nrow(),
    filter(pup_plant, `LST8-1` == TRUE) |> nrow(),
    filter(pup_plant, RAPTOR1 == TRUE) |> nrow()
  )
) |>
  mutate(method = ordered(method, levels = c("Pull-Down", "TAP", "PUP-IT")))

cell_quant <- tibble(
  "method" = rep(c("Pull-Down", "TAP", "PUP-IT"), each = 2),
  "bait" = rep(c("LST8-1", "RAPTOR1"), 3),
  "count" = c(
    filter(pd_cell, `LST8-1` == TRUE) |> nrow(),
    filter(pd_cell, RAPTOR1 == TRUE) |> nrow(),
    filter(tap_cell, `LST8-1` == TRUE) |> nrow(),
    filter(tap_cell, RAPTOR1 == TRUE) |> nrow(),
    filter(pup_cell, `LST8-1` == TRUE) |> nrow(),
    filter(pup_cell, RAPTOR1 == TRUE) |> nrow()
  )
) |>
  mutate(method = ordered(method, levels = c("Pull-Down", "TAP", "PUP-IT")))

area_plot <- function(data) {
  ggplot(
    data,
    aes(size = count)
  ) +
    geom_point(
      shape = 16,
      x = 0.5,
      y = 0.5,
      aes(colour = interaction(method, bait))
    ) +
    scale_size_area(
      max_size = 50
    ) +
    theme_void() +
    theme(legend.position = "none") +
    facet_grid(bait ~ method)
}

area_plot(plant_quant)
```



# Venn diagram with StringDB

## Format data

```{r}
core <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE/Q93YQ1_Q9LV27_P20081_min-5_ctrl-FALSE_GFP-TRUE_exclusive-FALSE_table.tsv"
  )
) |>
  distinct(protein) |>
  drop_na() |>
  pull(protein)

wider <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE/Q93YQ1_Q9LV27_P20081_min-3_ctrl-FALSE_GFP-TRUE_exclusive-FALSE_table.tsv"
  )
) |>
  distinct(protein) |>
  drop_na() |>
  pull(protein)

widest <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE/Q93YQ1_Q9LV27_P20081_min-2_ctrl-FALSE_GFP-FALSE_exclusive-FALSE_table.tsv"
  )
) |>
  distinct(protein) |>
  drop_na() |>
  pull(protein)

reported <- TORC_db |>
  pull(stringId_B)

overlaps <- data.frame(
  protein = c(core, wider, widest, reported, leene_proteins)
) |>
  distinct(protein) |>
  mutate(
    "Core" = case_when(
      protein %in% core ~ TRUE,
      TRUE ~ FALSE
    ),
    "Wider" = case_when(
      protein %in% wider ~ TRUE,
      TRUE ~ FALSE
    ),
    "Widest" = case_when(
      protein %in% widest ~ TRUE,
      TRUE ~ FALSE
    ),
    "StringDB" = case_when(
      protein %in% reported ~ TRUE,
      TRUE ~ FALSE
    ),
    "Van Leene et al., 2019" = case_when(
      protein %in% leene_proteins ~ TRUE,
      TRUE ~ FALSE
    )
  ) |>
  select(-protein)

for (i in 1:3) {
  x <- nrow(
    filter(
      overlaps,
      eval(parse(text = names(overlaps)[i])) == TRUE &
        eval(parse(text = names(overlaps)[4])) == TRUE
    )
  ) - 1
  m <- sum(overlaps[, 4])
  n <- 27448
  k <- sum(overlaps[, i])

  p <- phyper(
    x,
    m,
    n,
    k,
    lower.tail = FALSE
  )

  print(paste0(
    "P-value for the overlap of ", names(overlaps)[i], " and reported interactions in StringDB (",
    x, "/", k, " interactions overlapped with ", m, " StringDB entries",
    ") resulting from a random draw of the proteome (hypergeometric test): ", prettyNum(p, digits = 2)
  ))
}
```

## List reported proteins not found by us

```{r}
missing <- data.frame(
  protein = c(reported, leene_proteins)
) |>
  distinct(protein) |>
  mutate(
    "StringDB" = case_when(
      protein %in% reported ~ TRUE,
      TRUE ~ FALSE
    ),
    "Van Leene et al., 2019" = case_when(
      protein %in% leene_proteins ~ TRUE,
      TRUE ~ FALSE
    )
  ) |>
  filter(!(protein %in% widest))

missing_annotated <- UniprotR::GetProteinGOInfo(pull(missing, protein)) |>
  rownames_to_column("protein")
missing_names <- UniprotR::GetNamesTaxa(pull(missing, protein))

missing_full <- missing |>
  left_join(missing_names, by = join_by("protein" == "Entry")) |>
  left_join(missing_annotated)
```


## Plot diagram

```{r}
euler_overlaps <- euler(
  overlaps,
  shape = "ellipse"
)

string_euler_plot <- plot(
  euler_overlaps,
  quantities = list(fontfamily = "Helvetica", fontsize = text_size),
  # edges = list(lty = 2),
  labels = list(fontfamily = "Helvetica", fontsize = text_size, labels = c("Core", "Wider", "Widest", NA, NA)),
  legend = list(
    labels = c(
      "",
      "This study",
      "",
      "StringDB",
      "Van Leene et al., 2019"
    ),
    fontfamily = "Helvetica",
    fontsize = text_size
  ),
  fill = c(
    colorspace::lighten(pal_ostwald_disc[2], 0),
    colorspace::lighten(pal_ostwald_disc[2], 0.3),
    colorspace::lighten(pal_ostwald_disc[2], 0.6),
    pal_ostwald_disc[c(1, 4)]
  )
)

# pdf("venn.pdf", width = twocol * 1.2, height = onecol * 1.2)
string_euler_plot
# dev.off()
```

# Core, wide, wider benchmark

```{r}
bench_data <- readxl::read_xlsx(
  paste0(
    out_path,
    "filtering_benchmark.xlsx"
  )
) |>
  mutate(n = row_number()) |>
  filter(n %in% c(1, 7, 15)) |>
  mutate(
    strategy = rev(c("Core", "Wider", "Widest"))
  ) |>
  mutate(
    "High vs low confidence interactor ratio" = paste0(round(as.numeric(TP_FP_ratio), digits = 1), ":1")
  ) |>
  select(
    "Interactome" = strategy,
    "Min. sig. experiments" = min_overlap,
    "Stringent filter of promiscuous interactors" = filter_GFP,
    "Total interactors" = total_proteins,
    "StringDB" = stringdb,
    "Van Leene et al., 2019" = leene,
    "Interactors predicted to the thylakoid" = thylakoid_proteins,
    "High vs low confidence interactor ratio"
  )

tt(bench_data)
# save_tt("tab1.docx", overwrite = TRUE)
```

## Check for unspecific interactors

```{r}
core <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE/Q93YQ1_Q9LV27_P20081_min-5_ctrl-FALSE_GFP-TRUE_exclusive-FALSE_table.tsv"
  )
) |>
  distinct(protein) |>
  drop_na() |>
  mutate(evidence = "core")

wider <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE/Q93YQ1_Q9LV27_P20081_min-3_ctrl-FALSE_GFP-TRUE_exclusive-FALSE_table.tsv"
  )
) |>
  distinct(protein) |>
  drop_na() |>
  filter(!(protein %in% core$protein)) |>
  mutate(evidence = "wider")

widest <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE/Q93YQ1_Q9LV27_P20081_min-2_ctrl-FALSE_GFP-FALSE_exclusive-FALSE_table.tsv"
  )
) |>
  distinct(protein) |>
  drop_na() |>
  filter(!(protein %in% wider$protein) & !(protein %in% core$protein)) |>
  mutate(evidence = "widest")

proteomes <- bind_rows(core, wider, widest) |>
  full_join(ctrl_data) |>
  full_join(TORC_db |> select("protein" = stringId_B) |> mutate(stringdb = TRUE))
```

### Specificity Venn diagram

```{r}
spec_venn_data <- proteomes |>
  group_by(protein) |>
  summarise(
    core = case_when(
      evidence == "core" ~ TRUE,
      TRUE ~ FALSE
    ),
    wider = case_when(
      evidence %in% c("core", "wider") ~ TRUE,
      TRUE ~ FALSE
    ),
    widest = case_when(
      evidence %in% c("core", "wider", "widest") ~ TRUE,
      TRUE ~ FALSE
    ),
    string = case_when(
      stringdb == TRUE ~ TRUE,
      TRUE ~ FALSE
    ),
    control = case_when(
      n > 0 ~ TRUE,
      TRUE ~ FALSE
    )
  ) |>
  ungroup() |>
  select(-protein)

euler_overlaps <- euler(
  spec_venn_data,
  shape = "ellipse"
)

spec_plot <- plot(
  euler_overlaps,
  quantities = list(fontfamily = "Helvetica", fontsize = text_size),
  labels = list(fontfamily = "Helvetica", fontsize = text_size),
  fill = c(
    colorspace::lighten(pal_ostwald_disc[2], 0),
    colorspace::lighten(pal_ostwald_disc[2], 0.3),
    colorspace::lighten(pal_ostwald_disc[2], 0.6),
    pal_ostwald_disc[c(1, 4)]
  )
)

# pdf("control_venn.pdf")
spec_plot
# dev.off()
```

## GO enrichment

```{r}
core <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE/Q93YQ1_Q9LV27_P20081_min-5_ctrl-FALSE_GFP-TRUE_exclusive-FALSE_table.tsv"
  )
) |>
  distinct(gene) |>
  drop_na() |>
  pull(gene)

wider <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE/Q93YQ1_Q9LV27_P20081_min-3_ctrl-FALSE_GFP-TRUE_exclusive-FALSE_table.tsv"
  )
) |>
  distinct(gene) |>
  drop_na() |>
  pull(gene)

widest <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE/Q93YQ1_Q9LV27_P20081_min-2_ctrl-FALSE_GFP-FALSE_exclusive-FALSE_table.tsv"
  )
) |>
  distinct(gene) |>
  drop_na() |>
  pull(gene)

GO_en <- enrichGO(
  gene = wider,
  OrgDb = "org.At.tair.db",
  keyType = "TAIR",
  ont = "BP"
)

GO_pupit <- GO_en@result |>
  select(ID, Description, "pupit" = p.adjust)
```

### StringDB GO enrichment

```{r}
stringdb <- TORC_db |>
  pull(stringId_B)

string_go_data <- biomart(
  genes = stringdb, # query genes
  mart = "plants_mart", # subject biomart
  dataset = "athaliana_eg_gene", # subject dataset
  attributes = c(
    "ensembl_transcript_id", "description", "external_synonym", "namespace_1003", "name_1006", "interpro_description"
  ), # subject attributes
  filters = "uniprotswissprot" # ID type of the query
) |>
  bind_rows(biomart(
    genes = stringdb, # query genes
    mart = "plants_mart", # subject biomart
    dataset = "athaliana_eg_gene", # subject dataset
    attributes = c(
      "ensembl_transcript_id", "description", "external_synonym", "namespace_1003", "name_1006", "interpro_description"
    ), # subject attributes
    filters = "uniprotsptrembl" # ID type of the query
  )) |>
  distinct(ensembl_transcript_id) |>
  mutate(gene = str_remove(ensembl_transcript_id, "\\.[:digit:]")) |>
  pull(gene)

GO_string_en <- enrichGO(
  gene = string_go_data,
  OrgDb = "org.At.tair.db",
  keyType = "TAIR",
  ont = "BP"
)

GO_string <- GO_string_en@result |>
  select(ID, Description, "string" = p.adjust)
```

### Van Leene et al. (2019) GO enrichment

```{r}
leene_go_data <- biomart(
  genes = leene_proteins, # query genes
  mart = "plants_mart", # subject biomart
  dataset = "athaliana_eg_gene", # subject dataset
  attributes = c(
    "ensembl_transcript_id", "description", "external_synonym", "namespace_1003", "name_1006", "interpro_description"
  ), # subject attributes
  filters = "uniprotswissprot" # ID type of the query
) |>
  bind_rows(biomart(
    genes = leene_proteins, # query genes
    mart = "plants_mart", # subject biomart
    dataset = "athaliana_eg_gene", # subject dataset
    attributes = c(
      "ensembl_transcript_id", "description", "external_synonym", "namespace_1003", "name_1006", "interpro_description"
    ), # subject attributes
    filters = "uniprotsptrembl" # ID type of the query
  )) |>
  distinct(ensembl_transcript_id) |>
  mutate(gene = str_remove(ensembl_transcript_id, "\\.[:digit:]")) |>
  pull(gene)

GO_leene_en <- enrichGO(
  gene = leene_go_data,
  OrgDb = "org.At.tair.db",
  keyType = "TAIR",
  ont = "BP"
)

GO_leene <- GO_leene_en@result |>
  select(ID, Description, "leene" = p.adjust)
```

### Overlap with GO enrichment of known interactors

```{r}
GO_data <- full_join(GO_pupit, GO_string) |>
  full_join(GO_leene) |>
  mutate(
    string = case_when(
      is.na(string) ~ FALSE,
      string > 0.05 ~ FALSE,
      TRUE ~ TRUE
    ),
    pupit = case_when(
      is.na(pupit) ~ FALSE,
      pupit > 0.05 ~ FALSE,
      TRUE ~ TRUE
    ),
    leene = case_when(
      is.na(leene) ~ FALSE,
      leene > 0.05 ~ FALSE,
      TRUE ~ TRUE
    ),
  ) |>
  filter(string | pupit | leene)

GO_comp <- GO_data |>
  select(pupit, string, leene)

euler_overlaps <- euler(
  GO_comp,
  shape = "ellipse"
)

euler_plot <- plot(
  euler_overlaps,
  quantities = list(fontfamily = "Helvetica", fontsize = text_size),
  # edges = list(lty = 2),
  labels = list(fontfamily = "Helvetica", fontsize = text_size),
  legend = list(
    labels = c(
      "This study",
      "StringDB",
      "Van Leene et al., 2019"
    ),
    fontfamily = "Helvetica",
    fontsize = text_size
  ),
  fill = c(
    pal_ostwald_disc[c(2, 1, 4)]
  )
)

euler_plot

tt(GO_data |> filter(
  string == TRUE &
    leene == TRUE &
    pupit == TRUE
))
```

# Check lysine accessibility

## Download PDB files

```{r, eval=FALSE}
# Not evaluated because the calculated accessibility data is provided within the repository
proteins <- c(
  TORC_db |> pull(stringId_B),
  leene_data |> pull(stringId)
) |> unique()

for (i in 1:length(proteins)) {
  pred <- system(paste0("curl -X 'GET' 'https://alphafold.ebi.ac.uk/api/prediction/", proteins[i], "'"), intern = TRUE)

  url <- str_extract(pred, "(pdbUrl\":\")(.+\\.pdb)", group = 2)

  system(paste0("cd data/; wget ", url))
}
```

## Run DEPTH (CLI)

```{bash, eval=FALSE}
for i in *.pdb; do
    DEPTH \
    -i $i \
    -o DEPTH/$i \
    -thread 12
done 
```

## Run alphafold_disorder (CLI)

Run the below script from @Piovesan2022, slightly modified to use the ASA normalisation method from @Tien2013, in the CLI according to the function help.

```{python, eval=FALSE}
from Bio.PDB import PDBParser
from Bio.PDB.MMCIFParser import FastMMCIFParser
from Bio.SeqUtils import seq1
from Bio.PDB import DSSP
import numpy as np
import warnings
import pandas as pd
import argparse
import logging.config
import sys
import csv
from pathlib import Path, PurePath
import tempfile
import gzip
import shutil
import os


def moving_average(x, w):
    # https://stackoverflow.com/questions/13728392/moving-average-or-running-mean
    return np.convolve(x, np.ones(w), 'valid') / w


def is_gz_file(filepath):
    with open(filepath, 'rb') as test_f:
        return test_f.read(2) == b'\x1f\x8b'


def process_pdb(pdb_file, pdb_name, dssp_path='mkdssp'):
    # Decompress the structure if necessary
    real_file = pdb_file
    if is_gz_file(pdb_file):
        file_ext = Path(Path(pdb_file).stem).suffix
        fd, real_file = tempfile.mkstemp(prefix="alphafold-disorder_", suffix=file_ext)
        with open(real_file, "wb") as tmp:
            with gzip.open(pdb_file) as pdbf:
                shutil.copyfileobj(pdbf, tmp)
        os.close(fd)

    # Load the structure
    file_ext = Path(real_file).suffix
    if file_ext in ['.pdb']:
        structure = PDBParser(QUIET=True).get_structure('', real_file)
    else:
        # assume mmCIF
        structure = FastMMCIFParser(QUIET=True).get_structure('', real_file)

    # Calculate DSSP
    dssp = DSSP(structure[0], real_file, dssp=dssp_path, acc_array="Wilke")  # WARNING Check the path of mkdssp
    dssp_dict = dict(dssp)

    # Remove decompressed if necessary
    if real_file != pdb_file:
        Path(real_file).unlink()

    # Parse b-factor (pLDDT) and DSSP
    df = []
    for i, residue in enumerate(structure.get_residues()):
        lddt = residue['CA'].get_bfactor() / 100.0
        rsa = float(dssp_dict.get((residue.get_full_id()[2], residue.id))[3])
        ss = dssp_dict.get((residue.get_full_id()[2], residue.id))[2]
        df.append((pdb_name, i + 1, seq1(residue.get_resname()), lddt, 1 - lddt, rsa, ss))
    df = pd.DataFrame(df, columns=['name', 'pos', 'aa', 'lddt', 'disorder', 'rsa', 'ss'])
    return df


def make_prediction(df, window_rsa=[25], thresholds_rsa=[0.581]):
    for w in window_rsa:
        # Smooth disorder score (moving average)
        column_rsa_window = 'disorder-{}'.format(w)
        half_w = int((w - 1) / 2)
        df[column_rsa_window] = moving_average(np.pad(df['rsa'], (half_w, half_w), 'reflect'), half_w * 2 + 1)

        # Transofrm scores above RSA threshold
        for th_rsa in thresholds_rsa:
            column_rsa_binding = 'binding-{}-{}'.format(w, th_rsa)
            df[column_rsa_binding] = df[column_rsa_window].copy()
            df.loc[df[column_rsa_window] > th_rsa, column_rsa_binding] = df.loc[
                                                                             df[column_rsa_window] > th_rsa, 'lddt'] * (
                                                                                 1 - th_rsa) + th_rsa

    return df


def parse_args():
    parent_parser = argparse.ArgumentParser(add_help=False)

    group = parent_parser.add_mutually_exclusive_group(required=True)
    group.add_argument('-i', '--in_struct', type=str,
                       help='A single file, folder or file listing containing (gzipped) PDB or mmCIF files (relative paths)')
    group.add_argument('-d', '--in_dssp', type=str, help='A TSV file with RSA and pLDDT columns (checkpoint file)')

    parent_parser.add_argument('-o', '--out', type=str, required=True,
                               help='Output file. Automatically generate multiple files using this name, ignore extention')

    parent_parser.add_argument('-f', '--format', type=str, choices=['tsv', 'caid'], default='tsv', help='Output format')

    parent_parser.add_argument('-w', '--rsa_window', nargs='*', type=int, default=[25],
                               help='Apply a moving average over window on the RSA')
    parent_parser.add_argument('-t', '--rsa_threshold', nargs='*', type=float, default=[0.581],
                               help='In binding prediction, filter positions with RSA values under threshold')

    parent_parser.add_argument('-dssp', type=str, default='mkdssp', help='Path to mkdssp (3.x)')

    parent_parser.add_argument('-ll', type=str, choices=['notset', 'debug', 'info', 'warning', 'error', 'critical'],
                               default='info', help='Log level')

    main_parser = argparse.ArgumentParser(parents=[parent_parser])

    return main_parser.parse_args()


def process_file(f):
    result = pd.DataFrame([])
    if f.stat().st_size > 0:  # and 'P52799' in file.stem:  # 'P13693', 'P52799', 'P0AE72', 'Q13148'
        logging.debug('Processing PDB {}'.format(f))
        result = process_pdb(f, f.stem.split('.')[0], dssp_path=args.dssp)
    else:
        logging.debug('Empty file {}'.format(f))
    return result


if __name__ == '__main__':

    # parse command line arguments
    args = parse_args()
    fout_path = Path(args.out)

    # Set logger
    logging.basicConfig(format='%(asctime)s - %(process)d - %(name)s - %(levelname)s - %(message)s',
                        level=logging.getLevelName(args.ll.upper()), stream=sys.stdout)
    logging.getLogger('numexpr').setLevel(logging.WARNING)  # Remove numexpr warning

    # Disable pandas warnings
    warnings.simplefilter(action='ignore', category=FutureWarning)

    if args.in_struct:
        # Generate DSSP output from PDB files
        data = pd.DataFrame()
        p = Path(args.in_struct)
        if p.is_file():
            # input is a single struct file or file with list
            if ''.join(PurePath(p).suffixes) in ['.pdb', '.pdb.gz', '.cif', '.cif.gz']:
                # process single file as input
                processed_data = process_file(p)
                if not processed_data.empty:
                    data = data.append(processed_data)
            else:
                # process list of files as input (paths in list are relative)
                with open(p, 'r') as list_file:
                    for file in list_file:
                        real_file = Path(p.parent, Path(file.strip()))
                        processed_data = process_file(real_file)
                        if not processed_data.empty:
                            data = data.append(processed_data)
        else:
            # input is a directory
            for file in p.iterdir():
                processed_data = process_file(file)
                if not processed_data.empty:
                    data = data.append(processed_data)

        # Write a TSV file
        fout_name = '{}/{}_data.tsv'.format(fout_path.parent, fout_path.stem)
        data.to_csv(fout_name, sep='\t', quoting=csv.QUOTE_NONE, index=False, float_format='%.3f')
        logging.info('DSSP data written in {}'.format(fout_name))
    elif args.in_dssp:
        # Start from checkpoint file
        data = pd.read_csv(args.in_dssp, sep='\t')
        logging.info('DSSP data read from {}'.format(args.in_dssp))
    else:
        data = None

    # Calculate predictions
    pred = pd.DataFrame()
    for name, pdb_data in data.groupby('name'):
        pred = pred.append(make_prediction(pdb_data.copy(),
                                           window_rsa=args.rsa_window,
                                           thresholds_rsa=args.rsa_threshold))
    logging.info('Prediction calculated')

    # Write to file
    if args.format == 'tsv':
        fout_name = '{}/{}_pred.tsv'.format(fout_path.parent, fout_path.stem)
        pred.to_csv(fout_name, sep='\t', quoting=csv.QUOTE_NONE, index=False, float_format='%.3f')
        logging.info('Prediction written in {}'.format(fout_path))
    elif args.format == 'caid':
        methods = set(pred.head()) - {'name', 'pos', 'aa', 'lddt', 'rsa', 'ss'}
        for method in methods:
            with open('{}/{}_{}.dat'.format(fout_path.parent, fout_path.stem, method), 'w') as fout:
                for name, pdb_pred in pred.groupby('name'):
                    fout.write('>' + name + '\n' + (pdb_pred['pos'].astype(str) + '\t' + pdb_pred['aa'] + '\t' + pdb_pred[method].round(3).astype(str) + '\t').str.cat(sep='\n') + '\n')
        logging.info('CAID prediction files written in {}/'.format(fout_path.parent))
```


## Load lysine depth and asa

### Depth

```{r}
read_depth <- function(flnm) {
  read_tsv(
    flnm,
    skip = 1,
    col_select = c(1:3),
    col_names = c("pos", "residue", "depth"),
    show_col_types = FALSE
  ) |>
    mutate(filename = basename(flnm))
}

depth_files <- list.files(
  path = "data/output/DEPTH",
  pattern = "residue\\.depth",
  full.names = TRUE
)

depth_data <- map_dfr(depth_files, read_depth) |>
  filter(residue == "LYS") |>
  mutate(
    protein = str_extract(filename, "AF-([:alnum:]+)", group = 1),
    pos = as.numeric(str_extract(pos, "[:digit:]+"))
  ) |>
  select(-filename)
```

### ASA & IDR

```{r}
asa_data <- read_tsv(
  "data/output/alphafold_disorder_pred.tsv"
) |>
  filter(aa == "K") |>
  mutate(
    protein = str_extract(name, "AF-([:alnum:]+)", group = 1),
    residue = "LYS"
  ) |>
  select(protein, pos, residue, rsa, "idr" = `disorder-25`)
```


### Combine and group

```{r}
widest <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE/Q93YQ1_Q9LV27_P20081_min-2_ctrl-FALSE_GFP-FALSE_exclusive-FALSE_table.tsv"
  )
) |>
  distinct(protein) |>
  drop_na() |>
  pull(protein)

acc_data <- depth_data |>
  full_join(asa_data) |>
  filter(protein %in% TORC_db$stringId_B | protein %in% leene_proteins) |>
  mutate(
    enriched = case_when(
      protein %in% widest ~ TRUE,
      TRUE ~ FALSE
    ),
    detected = case_when(
      protein %in% interactions$protein ~ TRUE,
      TRUE ~ FALSE
    ),
    det_en = case_when(
      enriched == TRUE ~ TRUE,
      enriched == FALSE & detected == TRUE ~ FALSE,
      TRUE ~ NA
    ),
    StringDB = case_when(
      protein %in% TORC_db$stringId_B ~ TRUE,
      TRUE ~ FALSE
    ),
    VanLeene = case_when(
      protein %in% leene_data$stringId ~ TRUE,
      TRUE ~ FALSE
    ),
    HCM = case_when(
      enriched == FALSE & StringDB == TRUE & VanLeene == TRUE ~ TRUE,
      TRUE ~ FALSE
    )
  )

hcm <- acc_data |>
  filter(HCM == TRUE) |>
  distinct(protein)

idr_data <- acc_data |>
  filter(idr < 0.75)

idr_n <- idr_data |>
  group_by(protein, detected) |>
  summarise(n = n())

detection <- acc_data |>
  distinct(protein, .keep_all = TRUE) |>
  count(detected)

det_en <- acc_data |>
  distinct(protein, .keep_all = TRUE) |>
  count(det_en)
```

## Plot LYS accessibility

```{r}
# TODO: Check identified pupylation sites for depth/RSA
top_depth <- acc_data |>
  # filter(depth < 3.6) |>
  filter(rsa > 0.7) |>
  group_by(protein) |>
  summarise(
    across(where(is.numeric), median),
    across(where(is.logical), unique)
  )

full_depth <- acc_data |>
  filter(depth < 3.6) |>
  group_by(protein) |>
  summarise(
    across(where(is.logical), unique),
    count = n()
  )

full_rsa <- acc_data |>
  filter(rsa > 0.7) |>
  group_by(protein) |>
  group_by(protein) |>
  summarise(
    across(where(is.logical), unique),
    count = n()
  )

access_plot <- function(.x, .y, data) {
  x <- enquo(.x)
  y <- enquo(.y)
  data <- data |>
    drop_na(!!x) |>
    mutate(
      !!x := ordered(case_when(
        !!x == TRUE ~ "Detected",
        TRUE ~ "Not detected"
      ), levels = c("Detected", "Not detected"))
    )
  P <- kruskal.test(formula(substitute(.y ~ .x)), data = data)$p.value
  min <- min(data |> pull(!!y))
  max <- max(data |> pull(!!y)) + ((max(data |> pull(!!y)) - min) * 0.125)
  no <- data |>
    filter(!!x == "Not detected") |>
    pull(!!y) |>
    median()
  yes <- data |>
    filter(!!x == "Detected") |>
    pull(!!y) |>
    median()

  ggplot(
    data,
    aes(x = !!x, y = !!y)
  ) +
    geom_violin(
      aes(fill = !!x),
      # draw_quantiles = 0.5,
      scale = "width",
    ) +
    geom_boxplot(
      width = 0.1,
      fatten = 1,
      colour = "black",
      outliers = FALSE
    ) +
    annotate(
      "richtext",
      label = paste0("*P* = ", signs(P, format = prettyNum, digits = 2)),
      x = 1.5,
      y = min,
      label.size = NA,
      label.padding = unit(0.1, "lines"),
      # fill = NA,
      family = "Helvetica",
      size = ggtext_size
    ) +
    annotate(
      "segment",
      linewidth = 0.4,
      lineend = "square",
      x = 1,
      xend = 2,
      y = max,
      yend = max
    ) +
    annotate(
      "segment",
      linewidth = 0.4,
      x = 1,
      xend = 1,
      y = max,
      yend = max - ((max - min) * 0.075)
    ) +
    annotate(
      "segment",
      linewidth = 0.4,
      x = 2,
      xend = 2,
      y = max,
      yend = max - ((max - min) * 0.075),
      arrow = arrow(length = unit(0.03, "native"), type = "closed")
    ) +
    annotate(
      "richtext",
      label = ifelse(
        (no - yes) / yes > 0.5,
        paste0("<b>", signs(((no - yes) / yes) * 100, add_plusses = TRUE), "%</b>"),
        paste0(signs(((no - yes) / yes) * 100, add_plusses = TRUE), "%")
      ),
      x = 1.5,
      y = max,
      label.size = NA,
      label.padding = unit(0.1, "lines"),
      # fill = NA,
      family = "Helvetica",
      size = ggtext_size
    ) +
    scale_fill_manual(values = c(pal_ostwald_disc[2], "grey90")) +
    coord_cartesian(clip = "off") +
    theme_leo() +
    theme(
      axis.title.y = element_text(),
      legend.position = "none",
      axis.text.x = element_markdown()
    )
}


access_plot(detected, count, full_depth) + labs(y = "Surface Lys", x = "Detected in TORC PUP-IT") +
  access_plot(detected, count, full_rsa) + labs(y = "Solvent accessible Lys", x = "Detected in TORC PUP-IT") +
  access_plot(detected, idr, top_depth) + labs(y = "Lys disorder", x = "Detected in TORC PUP-IT") +
  access_plot(det_en, idr, top_depth) + labs(y = "Lys disorder", x = "Enriched in TORC PUP-IT") &
  plot_annotation(tag_levels = "A") &
  theme(
    plot.tag = element_text(size = 10, hjust = 1, vjust = 0, face = "bold", family = "Helvetica"),
    plot.tag.position = c(0, 1)
  )
```

## Identify missing proteins with ordered Lys

```{r}
should_be_found <- top_depth |>
  group_by(protein) |>
  summarise(mean_idr = mean(idr)) |>
  filter(mean_idr < 0.5) |>
  inner_join(missing_full)

should_be_found
# writexl::write_xlsx(should_be_found, "unexplained_missing.xlsx")
```

# Cluster interactors

Here I cluster all proteins we detected in our experiments according to their bait and time dependencies.

## Format data

```{r}
cluster_data_manual <- interactions |>
  separate(group1, into = c("species_1", "construct_1", "bait_1", "treatment_1", "time_1"), remove = FALSE) |>
  separate(group2, into = c("species_2", "construct_2", "bait_2", "treatment_2", "time_2"), remove = FALSE) |>
  filter(
    (treatment_1 == treatment_2 & time_1 == time_2) | # compare baits
      (bait_1 == bait_2 & time_1 == time_2) | # compare treatments
      (treatment_1 == treatment_2 & bait_1 == bait_2) # compare time points
  ) |>
  filter(!str_detect(bait_1, "GFP")) |>
  unite("group1", c(species_1, construct_1, bait_1, treatment_1, time_1), sep = "_") |>
  unite("group2", c(species_2, construct_2, bait_2, treatment_2, time_2), sep = "_") |>
  mutate(across(c(group1, group1), ~ str_remove_all(.x, "(_[:digit:])[_$]"))) |>
  mutate(
    # clearly mark the phospho-enriched batch
    group1 = case_when(
      batch == "R1067" ~ paste0(group1, "_TiO"),
      TRUE ~ group1
    ),
    group2 = case_when(
      batch == "R1067" ~ paste0(group2, "_TiO"),
      TRUE ~ group2
    ),
    comparison = paste(group1, group2, sep = "-")
  ) |>
  group_by(protein) |>
  summarise(
    "LST8 suc. 4h" = mean(logFC[str_detect(group1, "LST8_suc_4h") & str_detect(group2, "GFP_suc_4h")], na.rm = TRUE),
    "LST8 suc. 24h" = mean(logFC[str_detect(group1, "LST8_suc_24h") & str_detect(group2, "GFP_suc_24h")], na.rm = TRUE),
    "RAPTOR suc. 4h" = mean(logFC[str_detect(group1, "RAPTOR_suc_4h") & str_detect(group2, "GFP_suc_4h")], na.rm = TRUE),
    "RAPTOR suc. 24h" = mean(logFC[str_detect(group1, "RAPTOR_suc_24h") & str_detect(group2, "GFP_suc_24h")], na.rm = TRUE),
    "LST8 man. 4h" = mean(logFC[str_detect(group1, "LST8_(man|ctrl)_4h") & str_detect(group2, "GFP_(man|ctrl)_4h")], na.rm = TRUE),
    "LST8 man. 24h" = mean(logFC[str_detect(group1, "LST8_(man|ctrl)_24h") & str_detect(group2, "GFP_(man|ctrl)_24h")], na.rm = TRUE),
    "RAPTOR man. 4h" = mean(logFC[str_detect(group1, "RAPTOR_(man|ctrl)_4h") & str_detect(group2, "GFP_(man|ctrl)_4h")], na.rm = TRUE),
    "RAPTOR man. 24h" = mean(logFC[str_detect(group1, "RAPTOR_(man|ctrl)_24h") & str_detect(group2, "GFP_(man|ctrl)_24h")], na.rm = TRUE),
    "FKBP12 rap. 4h" = mean(logFC[str_detect(group1, "FKBP12_rap_4h") & str_detect(group2, "FKBP12_ctrl_4h")], na.rm = TRUE),
    "FKBP12 rap. 24h" = mean(logFC[str_detect(group1, "FKBP12_rap_24h") & str_detect(group2, "FKBP12_ctrl_24h")], na.rm = TRUE)
  ) |>
  mutate(across(-protein, ~ case_when(
    is.nan(.x) ~ 0,
    TRUE ~ .x
  )))

cluster_data_manual
```

## Clustering proteins

```{r}
cluster_mat <- cluster_data_manual |>
  column_to_rownames("protein")

clustering_raw <- hclust(
  dist(cluster_mat),
  method = "ward.D2"
)

clustering <- with(
  cluster_mat,
  reorder(
    clustering_raw,
    `RAPTOR suc. 4h`,
    agglo.FUN = "mean"
  )
)

plot(clustering, cex = 0.1, main = "Clustered proteins")
abline(h = 30, col = "blue")
```

### Cluster stats

```{r}
k <- 6
clusters <- cutree(clustering, k = 6) |>
  as_tibble(
    rownames = "protein"
  ) |>
  left_join(
    TORC_db,
    by = join_by("protein" == "stringId_B")
  ) |>
  left_join(
    leene_data |> distinct(stringId, .keep_all = TRUE),
    by = join_by("protein" == "stringId")
  ) |>
  mutate(
    evidence = case_when(
      !is.na(stringId_A) ~ "StringDB",
      !is.na(method) ~ "Van Leene et al., 2019",
      TRUE ~ "New"
    )
  )

export_clusters <- clusters |>
  select(protein, "Proteomics module" = value)

cluster_avg <- cluster_data_manual |>
  left_join(clusters) |>
  group_by(value) |>
  summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE)))
```

## Clustering categories

```{r}
cluster_mat <- cluster_data_manual |>
  select(-protein) |>
  as.matrix()

rownames(cluster_mat) <- pull(cluster_data_manual, protein)

cluster_t <- t(cluster_mat)

cluster_dist <- dist(cluster_t)

clustering_cat <- hclust(
  cluster_dist,
  method = "ward.D2"
)

plot(clustering_cat, cex = 0.6, main = "Clustered experiments")
abline(h = 60, col = "blue")

clusters_cat <- cutree(clustering_cat, k = 4) |>
  as_tibble(
    rownames = "category"
  ) |>
  rename("cat_value" = "value")
```

## ggplot2 heatmap

### Order data by clusters

```{r}
gg_clust_prot <- dendro_data(as.dendrogram(clustering))
gg_clust_cat <- dendro_data(as.dendrogram(clustering_cat))

core <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE/Q93YQ1_Q9LV27_P20081_min-5_ctrl-FALSE_GFP-TRUE_exclusive-FALSE_table.tsv"
  )
) |>
  distinct(protein) |>
  drop_na() |>
  pull(protein)

wider <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE/Q93YQ1_Q9LV27_P20081_min-3_ctrl-FALSE_GFP-TRUE_exclusive-FALSE_table.tsv"
  )
) |>
  distinct(protein) |>
  drop_na() |>
  pull(protein)

widest <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE/Q93YQ1_Q9LV27_P20081_min-2_ctrl-FALSE_GFP-FALSE_exclusive-FALSE_table.tsv"
  )
) |>
  distinct(protein) |>
  drop_na() |>
  pull(protein)

cluster_data_long <- cluster_data_manual |>
  pivot_longer(c(2:11), names_to = "category", values_to = "logFC") |>
  left_join(clusters) |>
  left_join(clusters_cat) |>
  mutate(
    protein = ordered(protein, levels = gg_clust_prot[["labels"]][["label"]]),
    category = ordered(category, levels = gg_clust_cat[["labels"]][["label"]]),
    interactome = case_when(
      protein %in% core ~ "Core",
      protein %in% wider ~ "Wider",
      protein %in% widest ~ "Widest",
      TRUE ~ NA
    )
  ) |>
  arrange(protein, category) |>
  mutate(
    value = ordered(value, levels = unique(value)),
    cat_value = ordered(cat_value, levels = unique(cat_value)),
  )

cluster_summary <- clusters |>
  group_by(value, evidence) |>
  summarise(n = n()) |>
  pivot_wider(names_from = evidence, values_from = n) |>
  group_by(value) |>
  mutate(
    rel_rep = sum(StringDB, `Van Leene et al., 2019`, na.rm = TRUE) / sum(New, StringDB, `Van Leene et al., 2019`, na.rm = TRUE),
    value = ordered(value, levels = levels(cluster_data_long$value))
  ) |>
  arrange(value)

cluster_summary
```

### Plot Heatmap

#### Heatmap

```{r}
hm_data <- cluster_data_long |>
  mutate(
    category = str_replace(category, "RAPTOR ", "RAPTOR1<br>"),
    category = str_replace(category, "LST8 ", "LST8-1<br>"),
    category = str_replace(category, "FKBP12 ", "*Sc*FKBP<br>"),
  )

hm <- ggplot(
  hm_data,
  aes(
    y = protein,
    x = category,
    fill = logFC
  )
) +
  geom_raster() +
  scale_fill_gradient2(
    low = pal_ostwald_disc[1],
    # mid = colorspace::lighten(pal_ostwald_disc[2], 0.75),
    mid = "white",
    high = pal_ostwald_disc[3],
    limits = c(-4, 4),
    oob = scales::squish,
    breaks = c(-4, 0, 4),
    labels = signs_format(),
    name = "log2FC"
  ) +
  scale_x_discrete(
    labels = scales::label_wrap(9)
  ) +
  guides(
    fill = guide_colorbar(
      title.position = "top",
      title.hjust = 0,
      barheight = unit(1, "mm"),
      barwidth = unit(8, "mm"),
      theme = theme(legend.ticks = element_blank())
    )
  ) +
  theme_leo() +
  theme(
    axis.text.y = element_blank(),
    strip.text.x = element_blank(),
    strip.text.y.left = element_markdown(
      angle = 0,
      vjust = 0.5,
      hjust = 1,
      face = "plain",
      margin = margin(r = 1, unit = "mm")
    ),
    strip.clip = "off",
    axis.line = element_blank(),
    legend.position = c(0.07, 0.97),
    legend.direction = "horizontal",
    plot.margin = margin(r = 3, unit = "mm"),
    panel.border = element_rect(
      fill = NA,
      colour = "black"
    )
  ) +
  coord_cartesian(
    expand = FALSE,
    clip = "off"
  ) +
  facet_grid(
    # cat_value ~ value,
    value ~ cat_value,
    scales = "free",
    space = "free",
    switch = "y"
  )

hm
```

#### Significance bar

```{r}
wider <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE/Q93YQ1_Q9LV27_P20081_min-3_ctrl-FALSE_GFP-TRUE_exclusive-FALSE_table.tsv"
  )
) |>
  pull(protein)

min_3_summary <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE/Q93YQ1_Q9LV27_P20081_min-3_ctrl-FALSE_GFP-TRUE_exclusive-FALSE_table.tsv"
  )
) |>
  distinct(protein) |>
  mutate(sig = "yes") |>
  full_join(cluster_data_long |> distinct(protein, value)) |>
  drop_na(protein) |>
  mutate(sig = case_when(
    is.na(sig) ~ "no",
    TRUE ~ sig
  )) |>
  group_by(value, sig) |>
  summarise(n = n()) |>
  pivot_wider(names_from = sig, values_from = n) |>
  group_by(value) |>
  mutate(
    yes = case_when(
      is.na(yes) ~ 0,
      TRUE ~ yes
    ),
    rel_sig = yes / sum(yes, no, na.rm = TRUE)
  )

sig_bar_data <- cluster_data_long |>
  select(protein, value) |>
  left_join(min_3_summary) |>
  distinct() |>
  mutate(
    sig = case_when(
      protein %in% wider ~ "yes",
      TRUE ~ "no"
    ),
    cat_value = "PUP-IT 'wider'",
    label = paste0(
      round(rel_sig * 100, digits = 0),
      "% (",
      yes,
      "/",
      yes + no,
      ")"
    )
  )

sig_bar <- ggplot(
  sig_bar_data,
  aes(y = protein, x = cat_value, fill = sig)
) +
  geom_raster() +
  geom_text(
    data = sig_bar_data |> group_by(value) |> arrange(protein, .by_group = TRUE) |> slice_head(n = 1),
    aes(x = 1.6, label = label),
    vjust = 0,
    hjust = 0,
    family = "Helvetica",
    size = ggtext_size
  ) +
  scale_fill_manual(values = c("white", pal_ostwald_disc[1])) +
  scale_x_discrete(
    labels = scales::label_wrap(17)
  ) +
  theme_leo() +
  theme(
    legend.position = "none",
    strip.text = element_blank(),
    axis.text.y = element_blank(),
    axis.text.x = element_markdown(hjust = 0),
    axis.line = element_blank(),
    plot.margin = margin(r = 15, unit = "mm"),
    panel.border = element_rect(
      fill = NA,
      colour = "black"
    )
  ) +
  coord_cartesian(
    expand = FALSE,
    xlim = c(0.5, 1.5),
    clip = "off"
  ) +
  facet_grid(
    # cat_value ~ value,
    value ~ cat_value,
    scales = "free",
    space = "free"
  )

sig_bar
```

#### Evidence bar

```{r}
evidence_bar_data <- cluster_data_long |>
  select(protein, value, evidence, interactome) |>
  left_join(cluster_summary) |>
  distinct() |>
  mutate(across(where(is.numeric), ~ replace_na(., 0))) |>
  mutate(
    cat_value = "Previous evidence",
    label = paste0(
      round(rel_rep * 100, digits = 0),
      "% (",
      StringDB + `Van Leene et al., 2019`,
      "/",
      New + StringDB + `Van Leene et al., 2019`,
      ")"
    )
  )

evidence_bar <- ggplot(
  evidence_bar_data,
  aes(y = protein, x = cat_value, fill = evidence == "StringDB" | evidence == "Van Leene et al., 2019")
) +
  geom_raster() +
  geom_text(
    data = evidence_bar_data |> group_by(value) |> arrange(protein, .by_group = TRUE) |> slice_head(n = 1),
    aes(x = 1.6, label = label),
    vjust = 0,
    hjust = 0,
    family = "Helvetica",
    size = ggtext_size
  ) +
  scale_fill_manual(values = c("white", pal_ostwald_disc[1])) +
  scale_x_discrete(
    labels = scales::label_wrap(17)
  ) +
  theme_leo() +
  theme(
    legend.position = "none",
    strip.text = element_blank(),
    axis.text.y = element_blank(),
    axis.text.x = element_markdown(hjust = 0),
    axis.line = element_blank(),
    plot.margin = margin(r = 15, unit = "mm"),
    panel.border = element_rect(
      fill = NA,
      colour = "black"
    )
  ) +
  coord_cartesian(
    expand = FALSE,
    xlim = c(0.5, 1.5),
    clip = "off"
  ) +
  facet_grid(
    # cat_value ~ value,
    value ~ cat_value,
    scales = "free",
    space = "free"
  )

evidence_bar
```

#### Dendrogram 

```{r}
hm_dendro <- ggplot() +
  geom_segment(
    data = segment(gg_clust_prot),
    aes(x = x, y = y, xend = xend, yend = yend)
  ) +
  # geom_text(data = label(gg_clust_prot),
  #           aes(x = x, y = y, label = label, hjust = 0),
  #           size = 3
  # ) +
  coord_flip(
    ylim = c(90, 30),
    # xlim = c(3100, 0),
    expand = FALSE
  ) +
  theme_void()

hm_dendro
```

#### Module table

```{r}
cluster_annotation <- tribble( # singleon = "across" & singlePeptide = TRUE
  ~cluster, ~description,
  "1", "Background",
  "2", "Early TORC sucrose reponse",
  "3", "Late unspecific sucrose response",
  "4", "Constitutive LST8-1 interactors",
  "5", "Late TORC sucrose reponse",
  "6", "Early unspecific sucrose response"
)

tt(
  cluster_annotation,
  caption = "Annotation of clusters resolved in the heatmap."
)
# save_tt("tab2.docx", overwrite = TRUE)
```

### GO terms

#### GFP clusters

```{r}
gfp_prot <- cluster_data_long |>
  filter(value == 3 | value == 6) |>
  pull(protein) |>
  unique()

gfp_go_data <- biomart(
  genes = gfp_prot, # query genes
  mart = "plants_mart", # subject biomart
  dataset = "athaliana_eg_gene", # subject dataset
  attributes = c(
    "ensembl_transcript_id", "description", "external_synonym", "namespace_1003", "name_1006", "interpro_description"
  ), # subject attributes
  filters = "uniprotswissprot" # ID type of the query
) |>
  bind_rows(biomart(
    genes = gfp_prot, # query genes
    mart = "plants_mart", # subject biomart
    dataset = "athaliana_eg_gene", # subject dataset
    attributes = c(
      "ensembl_transcript_id", "description", "external_synonym", "namespace_1003", "name_1006", "interpro_description"
    ), # subject attributes
    filters = "uniprotsptrembl" # ID type of the query
  )) |>
  distinct(ensembl_transcript_id) |>
  mutate(gene = str_remove(ensembl_transcript_id, "\\.[:digit:]")) |>
  pull(gene)

GO_gfp_en <- enrichGO(
  gene = gfp_go_data,
  OrgDb = "org.At.tair.db",
  keyType = "TAIR",
  ont = "BP"
)

GO_gfp <- GO_gfp_en@result |>
  select(ID, Description, "string" = p.adjust)
```

# Phosphoproteomics

## Load all detected phospho sites

```{r}
sites <- read_tsv(
  paste0(out_path, "phosphoproteomics/FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE_site_FC_annotated.tsv")
) |>
  drop_na(protein) |>
  separate(group1, into = c("species_1", "construct_1", "bait_1", "treatment_1", "time_1"), remove = FALSE) |>
  separate(group2, into = c("species_2", "construct_2", "bait_2", "treatment_2", "time_2"), remove = FALSE) |>
  filter(
    time_1 == time_2 &
      str_detect(bait_2, "GFP") &
      !str_detect(bait_1, "GFP")
  ) |>
  mutate(time = time_1) |>
  unite("group1", c(species_1, construct_1, bait_1, treatment_1, time_1), sep = "_") |>
  unite("group2", c(species_2, construct_2, bait_2, treatment_2, time_2), sep = "_") |>
  mutate(across(c(group1, group1), ~ str_remove_all(.x, "(_[:digit:])[_$]"))) |>
  mutate(bait = case_when(
    str_detect(group1, "LST8") ~ "LST8",
    TRUE ~ "RAPTOR"
  )) |>
  select(protein, Index, time, bait, logFC, adjPval) |>
  group_by(protein, Index, time) |>
  distinct() |>
  pivot_wider(
    names_from = bait,
    values_from = c(logFC, adjPval)
  )

sites
```

## Load Van Leene phosphosites

```{r}
leene_sites <- read_tsv(
  "data/published/leene_p_sites.tsv"
) |>
  mutate(gene = str_remove(Protein, "\\.[:digit:]")) |>
  left_join(
    read_tsv(
      paste0(out_path, "phosphoproteomics/FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE_site_FC_annotated.tsv")
    ) |>
      distinct(Index, gene, .keep_all = TRUE),
    by = "gene"
  ) |>
  mutate(leene_index = paste(protein, Residue, sep = "_")) |>
  drop_na(protein) |>
  mutate(match = case_when(
    Index == leene_index ~ "Site",
    TRUE ~ "Protein"
  ))
```

## List highly enriched proteins

```{r}
phospho_candidates <- sites |>
  mutate(
    evidence = case_when(
      Index %in% pull(leene_sites, leene_index) ~ "Site",
      protein %in% pull(leene_sites, protein) ~ "Protein",
      (logFC_LST8 > 1 & adjPval_LST8 < 0.05) |
        (logFC_RAPTOR > 1 & adjPval_RAPTOR < 0.05) ~ "New",
      TRUE ~ "Background"
    )
  ) |>
  filter(logFC_LST8 > 5 & logFC_RAPTOR > 5) |>
  arrange(evidence)

phospho_prot <- phospho_candidates |>
  pull(protein) |>
  unique()

result <- biomart(
  genes = phospho_prot, # query genes
  mart = "plants_mart", # subject biomart
  dataset = "athaliana_eg_gene", # subject dataset
  attributes = c(
    "ensembl_transcript_id", "description", "external_synonym", "namespace_1003", "name_1006", "interpro_description"
  ), # subject attributes
  filters = "uniprotswissprot" # ID type of the query
)

# Collapse data frame to one row per protein
results_list <- result |>
  mutate(gene = str_remove_all(ensembl_transcript_id, "\\..+")) |>
  group_by(gene, external_synonym, description, interpro_description) |>
  filter(namespace_1003 != "") |>
  pivot_wider(names_from = namespace_1003, values_from = name_1006, values_fn = ~ paste(sort(unique(.x)), collapse = "; ")) |>
  group_by(gene) |>
  summarise(
    Protein = unique(uniprotswissprot),
    Synonyms = paste(unique(external_synonym), collapse = ";<br>"),
    `GO cellular component` = paste(unique(cellular_component), collapse = "; "),
    `GO biological process` = paste(unique(biological_process), collapse = "; "),
    `GO molecular function` = paste(unique(molecular_function), collapse = "; "),
    Description = unique(description),
    `Interpro terms` = paste(
      unique(interpro_description),
      collapse = "; "
    )
  )
```


## Plot phospho sites in LST/RAPTOR vs GFP

```{r}
FC_phospho_scatter <- function(time_point) {
  data <- sites |>
    filter(time == time_point) |>
    mutate(
      evidence = case_when(
        Index %in% pull(leene_sites, leene_index) ~ "Site",
        protein %in% pull(leene_sites, protein) ~ "Protein",
        (logFC_LST8 > 1 & adjPval_LST8 < 0.05) |
          (logFC_RAPTOR > 1 & adjPval_RAPTOR < 0.05) ~ "New",
        TRUE ~ "Background"
      ),
      sig = case_when(
        (logFC_LST8 > 1 & adjPval_LST8 < 0.05) |
          (logFC_RAPTOR > 1 & adjPval_RAPTOR < 0.05) ~ 1,
        TRUE ~ 0.4
      )
    ) |>
    left_join(leene_sites |> select(protein, Symbol), multiple = "first") |>
    arrange(evidence) |>
    mutate(Symbol = case_when(protein == "Q8L5Y9" ~ "PANK2", TRUE ~ Symbol))

  ggplot(
    data,
    aes(
      x = logFC_RAPTOR,
      y = logFC_LST8,
      group = protein
    )
  ) +
    geom_abline(
      slope = 1,
      linetype = 2
    ) +
    geom_point(
      data = data,
      aes(
        fill = evidence,
        alpha = sig
      ),
      shape = 21,
      size = 2,
      colour = "white",
      stroke = 0.2
    ) +
    geom_label_repel(
      data = filter(data, (evidence == "Site" & sig == 1) | (protein == "Q8L5Y9" & sig == 1)),
      min.segment.length = 0,
      aes(label = Symbol),
      label.size = NA,
      label.padding = unit(0.05, "lines"),
      fill = rgb(1, 1, 1, 0.5),
      family = "Helvetica",
      size = ggtext_size,
      hjust = 0
    ) +
    scale_fill_manual(
      values = c(
        "Background" = "grey90",
        "Bait" = pal_ostwald_disc[3],
        "New" = pal_ostwald_disc[2],
        "Site" = pal_ostwald_disc[1],
        "Protein" = pal_ostwald_disc[4]
      )
    ) +
    scale_alpha_identity(
      guide = "none"
    ) +
    labs(
      title = time_point,
      x = "LogFC RAPTOR1 vs. GFP",
      y = "LogFC LST8-1 vs. GFP"
    ) +
    guides(fill = guide_legend(
      title = "Overlap with Van Leene et al., 2019",
      title.position = "top"
    )) +
    theme_leo() +
    theme(
      axis.title = element_text(),
      legend.position = "bottom"
    ) +
    coord_fixed(
      ylim = c(-6, 8),
      xlim = c(-6, 8)
    )
}

FC_phospho_scatter("4h") + FC_phospho_scatter("24h") +
  plot_layout(guides = "collect") &
  theme(legend.position = "bottom")

# ggsave(
#   "phospho.pdf",
#   width = 120,
#   height = 80,
#   units = "mm"
# )
```

## Load enriched phospho sites

```{r}
sig_sites <- read_tsv(paste0(out_path, "phosphoproteomics/FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE_PUPIT_p_sites.tsv")) |>
  filter(logFC > 1 & adjPval < 0.05) |>
  separate(group1, into = c("species_1", "construct_1", "bait_1", "treatment_1", "time_1"), remove = FALSE) |>
  separate(group2, into = c("species_2", "construct_2", "bait_2", "treatment_2", "time_2"), remove = FALSE) |>
  filter(
    (treatment_1 == treatment_2 & time_1 == time_2) | # compare baits
      (bait_1 == bait_2 & time_1 == time_2) | # compare treatments
      (treatment_1 == treatment_2 & bait_1 == bait_2) # compare time points
  ) |>
  filter(!str_detect(bait_1, "GFP")) |>
  unite("group1", c(species_1, construct_1, bait_1, treatment_1, time_1), sep = "_") |>
  unite("group2", c(species_2, construct_2, bait_2, treatment_2, time_2), sep = "_") |>
  mutate(across(c(group1, group1), ~ str_remove_all(.x, "(_[:digit:])[_$]"))) |>
  distinct(Index, .keep_all = TRUE) |>
  mutate(position = as.numeric(str_extract(Index, "_[STY]([:digit:]+)", group = 1))) |>
  drop_na(protein)

sig_sites
export_sig_sites <- sig_sites |>
  select(Index) |>
  separate_wider_delim(
    Index,
    names = c("protein", "site"),
    delim = "_"
  ) |>
  group_by(protein) |>
  summarise("Enriched phosphosites" = str_c(site, collapse = "; "))
```

## Identify motifs

```{r, results='asis'}
accs <- sig_sites |> pull(protein)

seqs <- map(
  accs,
  ~ seqinr::read.fasta(
    paste0("https://rest.uniprot.org/uniprotkb/", .x, ".fasta"),
    as.string = TRUE, seqonly = TRUE
  )[[1]]
) |>
  unlist()

sig_sites <- sig_sites |>
  mutate(
    seq = seqs,
    window = str_sub(seq, scales::squish(position - 5, range = c(1, Inf)), position + 5),
    window = case_when(
      position < 6 ~ paste0(str_dup("X", 6 - position), window),
      nchar(window) < 11 ~ paste0(window, str_dup("X", 11 - nchar(window))),
      TRUE ~ window
    ),
    window = str_replace(window, "([:upper:]{5}[STY])([:upper:]{5})", "\\1\\[79.9663\\]\\2")
  )

# write_tsv(
#   sig_sites |> select(Index, window),
#   paste0(out_path, "window.tsv")
# )
#
# system(
#   paste0(
#     "/MEME/bin/momo ",
#     "modl ",
#     # "motifx ",
#     "--sequence-column window --width 11 ",
#     "--max-no-decrease 50 ",
#     # "--single-motif-per-mass ",
#     "--oc ",
#     out_path,
#     "momo_out --protein-database ",
#     out_path,
#     "proteome/FP_At_ref.fasta ",
#     out_path,
#     "window.tsv"
#   )
# )

cat(paste0("We find ", nrow(sig_sites), " phosphosites that are significantly enriched in LST8 and/or RAPTOR vs GFP."))
```

### Plot with ggseqlogo

```{r}
RS_motif <- read_tsv(
  "data/output/momo.txt",
  skip = 9,
  trim_ws = TRUE,
  col_names = c("A", "C", "D", "E", "F", "G", "H", "I", "K", "L", "M", "N", "P", "Q", "R", "S", "T", "V", "W", "Y")
) |>
  select(-X21) |>
  slice_head(n = 11) |>
  as.matrix() |>
  t()

RS_logo <- ggplot() +
  geom_logo(
    data = RS_motif,
    method = "custom",
    seq_type = "aa"
  ) +
  scale_y_continuous(breaks = c(0, 0.5, 1), labels = c("0", "50", "100")) +
  scale_x_continuous(breaks = c(1, 6, 11), labels = c("−5", "0", "5")) +
  labs(y = "Probability [%]") +
  theme_leo() +
  theme(
    legend.position = "none",
    axis.title.y = element_text()
  )

RS_logo

SP_motif <- read_tsv(
  "data/output/momo.txt",
  skip = 9,
  trim_ws = TRUE,
  col_names = c("A", "C", "D", "E", "F", "G", "H", "I", "K", "L", "M", "N", "P", "Q", "R", "S", "T", "V", "W", "Y")
) |>
  filter(row_number() > 13 & row_number() < 25) |>
  select(-X21) |>
  as.matrix() |>
  t()

SP_logo <- ggplot() +
  geom_logo(
    data = SP_motif,
    method = "custom",
    seq_type = "aa"
  ) +
  scale_y_continuous(breaks = c(0, 0.5, 1), labels = c("0", "50", "100")) +
  scale_x_continuous(breaks = c(1, 6, 11), labels = c("−5", "0", "5")) +
  labs(y = "Probability [%]") +
  theme_leo() +
  theme(
    legend.position = "none",
    axis.title.y = element_text()
  )

SP_logo
```

# Export candidate lists

```{r}
annotation <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE/Q93YQ1_Q9LV27_P20081_min-2_ctrl-FALSE_GFP-FALSE_exclusive-FALSE_table.tsv"
  )
) |>
  distinct(protein, .keep_all = TRUE) |>
  select(c(1, 11:17))

core <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE/Q93YQ1_Q9LV27_P20081_min-5_ctrl-FALSE_GFP-TRUE_exclusive-FALSE_table.tsv"
  )
) |>
  filter(!str_detect(group1, "TiO")) |>
  distinct(protein) |>
  drop_na() |>
  pull(protein)

mod4 <- cluster_data_long |>
  filter(value == 4) |>
  filter(!is.na(interactome)) |>
  select(protein, "module" = value, interactome, evidence) |>
  distinct() |>
  left_join(annotation)

core_data <- cluster_data_long |>
  filter(protein %in% core) |>
  select(protein, "module" = value, interactome, evidence) |>
  distinct() |>
  left_join(annotation)

phospho_candidates <- sites |>
  mutate(
    evidence = case_when(
      Index %in% pull(leene_sites, leene_index) ~ "Site",
      protein %in% pull(leene_sites, protein) ~ "Protein",
      (logFC_LST8 > 1 & adjPval_LST8 < 0.05) |
        (logFC_RAPTOR > 1 & adjPval_RAPTOR < 0.05) ~ "New",
      TRUE ~ "Background"
    )
  )

indices <- phospho_candidates |>
  mutate(Index = str_remove(Index, ".+\\_")) |>
  group_by(protein) |>
  summarise(sites = paste(unique(Index), collapse = "; "))

phospho <- cluster_data_long |>
  filter(protein %in% phospho_candidates$protein) |>
  filter(!is.na(interactome)) |>
  select(protein, "module" = value, interactome, evidence) |>
  distinct() |>
  left_join(indices) |>
  left_join(annotation)

full_candidates <- full_join(phospho, mod4) |>
  full_join(core_data) |>
  mutate(
    overlap = case_when(
      !is.na(sites) & protein %in% core & module == 4 ~ 3,
      (!is.na(sites) & protein %in% core) |
        (!is.na(sites) & module == 4) |
        (protein %in% core & module == 4) ~ 2,
      TRUE ~ 1
    ),
    .after = sites
  ) |>
  arrange(desc(overlap))

# writexl::write_xlsx(
#   full_candidates,
#   "candidates.xlsx"
# )
```

# Co-expression analysis

## Export list for co-expression analysis

```{r}
proteins <- c(
  TORC_db |> pull(stringId_B),
  leene_data |> pull(stringId)
) |> unique()

core <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE/Q93YQ1_Q9LV27_P20081_min-5_ctrl-FALSE_GFP-TRUE_exclusive-FALSE_table.tsv"
  )
) |>
  distinct(protein) |>
  drop_na() |>
  pull(protein)

wider <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE/Q93YQ1_Q9LV27_P20081_min-3_ctrl-FALSE_GFP-TRUE_exclusive-FALSE_table.tsv"
  )
) |>
  distinct(protein) |>
  drop_na() |>
  pull(protein)

widest <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE/Q93YQ1_Q9LV27_P20081_min-2_ctrl-FALSE_GFP-FALSE_exclusive-FALSE_table.tsv"
  )
) |>
  distinct(protein) |>
  drop_na() |>
  pull(protein)

reported_interactors <-
  tibble(protein = proteins) |>
  mutate(
    evidence = case_when(
      protein %in% core ~ "Core",
      protein %in% wider ~ "Wider",
      protein %in% widest ~ "Widest",
      protein %in% interactions$protein ~ "Not enriched",
      TRUE ~ "Not detected"
    ),
    evidence = ordered(evidence, levels = c("Core", "Wider", "Widest", "Not enriched", "Not detected"))
  ) |>
  arrange(evidence)

# writexl::write_xlsx(reported_interactors, "reported_interactors.xlsx")
```

## Results

### Load data

```{r}
coexp_data <- read_tsv("data/coexpression/source_target_staffan.tsv")
candidates <- readxl::read_excel("data/coexpression/candidates.xlsx")
reported <- readxl::read_excel("data/coexpression/reported_interactors.xlsx")

TORC_coexp <- coexp_data |>
  filter(source %in% c("AT1G50030", "AT3G18140", "AT3G08850") |
    target %in% c("AT1G50030", "AT3G18140", "AT3G08850")) |>
  mutate(
    pair = map2(source, target, c),
    pair = str_replace(pair, "AT1G50030", "TOR"),
    pair = str_replace(pair, "AT3G18140", "LST8-1"),
    pair = str_replace(pair, "AT3G08850", "RAPTOR1"),
    pair = map(pair, sort),
    source = str_extract(pair, "TOR|LST8-1|RAPTOR1"),
    target = str_extract(pair, "AT.{1}G[:digit:]{5}")
  ) |>
  full_join(candidates, by = join_by("target" == "gene")) |>
  drop_na(source, protein) |>
  mutate(substrate = !is.na(sites))
```

### Overall distribution

```{r}
total <- tibble(
  value = rnorm(100000)
) |>
  mutate(
    subset = "Whole genome",
    mean = mean(value),
    sd = sd(value),
    `Co-exp` = (value - mean) / sd
  )

candidate_coexp <- coexp_data |>
  filter(source %in% candidates$gene & target %in% candidates$gene) |>
  select(`Co-exp`) |>
  mutate(subset = "PUP-IT interactors")

reported_coexp <- coexp_data |>
  filter(!(source %in% candidates$gene) & !(target %in% candidates$gene)) |>
  select(`Co-exp`) |>
  mutate(subset = "Previously reported interactors")

dist_data <- bind_rows(total, candidate_coexp, reported_coexp) |>
  mutate(subset = ordered(subset, levels = c("Whole genome", "Previously reported interactors", "PUP-IT interactors")))

coexp_dist <- ggplot(
  dist_data,
  aes(x = `Co-exp`)
) +
  geom_density(
    aes(fill = subset),
    alpha = 0.5,
    colour = "white",
    adjust = 2
  ) +
  scale_fill_manual(values = c("grey80", pal_ostwald_disc[1:2])) +
  coord_cartesian(xlim = c(-3, 3), expand = F) +
  labs(
    x = "Co-expression Z-score",
    y = "Density"
  ) +
  theme_leo() +
  theme(
    axis.title = element_text(),
    axis.text.y = element_blank(),
    legend.title = element_blank(),
    legend.key.height = unit(2, "mm"),
    legend.key.width = unit(2, "mm")
  )

coexp_dist
```

### Substrates vs. interactors

```{r}
ggplot(
  TORC_coexp,
  aes(x = substrate, y = `Co-exp`)
) +
  geom_violin(
    aes(fill = substrate),
    scale = "width",
  ) +
  geom_boxplot(
    width = 0.1,
    outliers = FALSE
  ) +
  scale_fill_manual(values = pal_ostwald_disc[c(2, 4)]) +
  facet_wrap(~source) +
  theme_leo()
```

### Compare interactomes

```{r}
ggplot(
  TORC_coexp,
  aes(x = interactome, y = `Co-exp`)
) +
  geom_violin(
    aes(fill = interactome),
    scale = "width",
  ) +
  geom_boxplot(
    width = 0.1,
    outliers = FALSE
  ) +
  scale_fill_manual(
    values = c(
      colorspace::lighten(pal_ostwald_disc[2], 0),
      colorspace::lighten(pal_ostwald_disc[2], 0.3),
      colorspace::lighten(pal_ostwald_disc[2], 0.6)
    )
  ) +
  facet_wrap(~source) +
  theme_leo()
```

### Compare modules

```{r}
ggplot(
  TORC_coexp,
  aes(x = module, y = `Co-exp`)
) +
  geom_violin(
    aes(fill = module),
    scale = "width",
  ) +
  geom_boxplot(
    width = 0.1,
    outliers = FALSE
  ) +
  scale_fill_grey() +
  facet_wrap(~source) +
  theme_leo()
```

### Compare with control data

```{r}
ggplot(
  TORC_coexp |> left_join(ctrl_data) |> mutate(specific = is.na(n)),
  aes(x = specific, y = `Co-exp`)
) +
  geom_violin(
    aes(fill = specific),
    scale = "width",
  ) +
  geom_boxplot(
    width = 0.1,
    outliers = FALSE
  ) +
  scale_fill_manual(values = pal_ostwald_disc[c(4, 2)]) +
  facet_wrap(~source) +
  theme_leo()
```

### Compare with published data

```{r}
ggplot(
  TORC_coexp,
  aes(x = evidence == "New", y = `Co-exp`)
) +
  geom_violin(
    aes(fill = evidence == "New"),
    scale = "width",
  ) +
  geom_boxplot(
    width = 0.1,
    outliers = FALSE
  ) +
  scale_fill_manual(values = pal_ostwald_disc[c(4, 2)]) +
  facet_wrap(~source) +
  theme_leo()
```

### Cumulative logFC vs co-exp

#### Format data

```{r}
database <- read_tsv("data/output/FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE_PUPIT_interactions.tsv")

net <- database |>
  filter(protein %in% pull(TORC_coexp, protein)) |>
  filter(bait %in% c(LST8[1], RAPTOR[1])) |>
  mutate(bait = case_when(
    bait == LST8[1] ~ LST8[2],
    bait == RAPTOR[1] ~ RAPTOR[2]
  )) |>
  # this block limits comparisons to only differ in one of bait, treatment or time point -->
  separate(group1, into = c("species_1", "construct_1", "bait_1", "treatment_1", "time_1")) |>
  separate(group2, into = c("species_2", "construct_2", "bait_2", "treatment_2", "time_2")) |>
  filter(
    (treatment_1 == treatment_2 & time_1 == time_2) | # compare baits
      (bait_1 == bait_2 & time_1 == time_2) | # compare treatments
      (treatment_1 == treatment_2 & bait_1 == bait_2) # compare time points
  ) |>
  unite("group1", c(species_1, construct_1, bait_1, treatment_1, time_1), sep = "_") |>
  unite("group2", c(species_2, construct_2, bait_2, treatment_2, time_2), sep = "_") |>
  mutate(across(c(group1, group2), ~ str_remove_all(.x, "(_[:digit:])[_$]"))) |>
  # --|
  mutate(
    # clearly mark the phospho-enriched batch
    group1 = case_when(
      batch == "R1067" ~ paste0(group1, "_TiO"),
      TRUE ~ group1
    ),
    group2 = case_when(
      batch == "R1067" ~ paste0(group2, "_TiO"),
      TRUE ~ group2
    )
  )

edges <- net |>
  drop_na(protein) |>
  mutate(
    comp = paste(group1, "vs.", group2),
    instance = batch,
  ) |>
  group_by(bait, protein, instance) |>
  mutate(maxlogFC = max(logFC)) |>
  group_by(bait, protein) |>
  summarise(
    sumlogFC = round(sum(unique(maxlogFC)), 1),
    comps = paste0("<br>", paste(unique(comp), collapse = ",<br>")),
    exps = length(unique(instance))
  ) |>
  mutate(
    width = scales::squish(sumlogFC^2, range = c(1, 60)),
    title = paste0(
      "Robustness (cum. log<sub>2</sub>FC): ", sumlogFC,
      "<br>Comparisons: ", comps,
      "<br>No. of experiments: ", exps
    )
  ) |>
  left_join(TORC_coexp) |>
  mutate(evidence = ordered(evidence, levels = c("New", "Van Leene et al., 2019", "StringDB"))) |>
  arrange(evidence)
```

#### Plot

```{r}
ann <- tibble(
  "Co-exp" = c(1.5, 1.86),
  "sumlogFC" = c(16, 16),
  "label" = c("Coexp. cut-offs", "Coexp. cut-offs"),
  "bait" = "LST8-1", "source" = "LST8-1"
)

coexp_logfc <- ggplot(
  edges,
  aes(y = sumlogFC, x = `Co-exp`)
) +
  annotate(
    "rect",
    fill = rgb(0.5, 0.5, 0.5, 0.1),
    xmax = c(1.5, 1.86),
    xmin = -Inf,
    ymin = -Inf,
    ymax = Inf
  ) +
  geom_point(
    aes(fill = evidence),
    colour = "white",
    shape = 21,
    stroke = 0.2,
    size = 1
  ) +
  geom_text(
    data = slice_head(ann, n = 1),
    aes(
      x = `Co-exp` - 0.3,
      label = label
    ),
    family = "Helvetica",
    size = ggtext_size * 0.8,
    hjust = 1,
    vjust = 0
  ) +
  geom_curve(
    data = ann,
    aes(
      x = 1.25,
      y = sumlogFC,
      xend = `Co-exp` - 0.02,
      yend = 14.5
    ),
    curvature = -0.2,
    arrow = arrow(length = unit(0.5, "mm")),
    linewidth = 0.2
  ) +
  scale_fill_manual(values = pal_ostwald_disc[c(2, 4, 1)]) +
  labs(
    y = "Cumulative PUP-IT logFC",
    x = "Co-expression Z-score"
  ) +
  facet_grid(bait ~ source) +
  coord_cartesian(clip = "off", ylim = c(NA, 14)) +
  theme_leo() +
  theme(
    axis.title = element_text(),
    legend.title = element_blank()
  )

coexp_logfc
```

### Network analysis

#### Format data

```{r}
coex_igraph <- coexp_data |>
  filter(source %in% candidates$gene & target %in% candidates$gene) |>
  rename("weight" = `Co-exp`) |>
  filter(weight > 1.86) |>
  graph_from_data_frame(directed = FALSE)

coexp_comp <- components(coex_igraph)
large_clusters <- which(coexp_comp$csize > 3)
connected_nodes <- V(coex_igraph)[coexp_comp$membership %in% large_clusters]
coex_filtered <- induced_subgraph(coex_igraph, connected_nodes)

plot(coex_filtered, layout = layout_with_fr, vertex.label = NA, vertex.size = 5)
```

#### Cluster analysis

```{r}
coexp_evidence <- TORC_coexp |>
  distinct(target, .keep_all = TRUE) |>
  select("name" = target, evidence)

gg_coex <- as_tbl_graph(coex_filtered) |>
  activate(nodes) |>
  mutate(
    group = as.character(group_leiden(resolution = 0.0008)),
    label = case_when(
      name == "AT1G50030" ~ "TOR",
      name == "AT3G18140" ~ "LST8-1",
      name == "AT3G08850" ~ "RAPTOR1",
      TRUE ~ NA
    )
  ) |>
  left_join(coexp_evidence) |>
  mutate(evidence = case_when(is.na(evidence) ~ "StringDB", TRUE ~ evidence))
```

#### GO enrichment

```{r}
clusters <- gg_coex |>
  activate(nodes) |>
  as_tibble() |>
  group_split(group) |>
  map(~ pull(.x, "name"))

export_coex_clusters <- gg_coex |>
  activate(nodes) |>
  as_tibble() |>
  select("Gene" = name, "Coexpression cluster" = group)

GO_en <- map(
  clusters,
  \(x) enrichGO(
    gene = x,
    OrgDb = "org.At.tair.db",
    keyType = "TAIR",
    ont = "BP"
  )
)

GO_coexp <- map_dfr(
  GO_en,
  \(x) x@result,
  .id = "group"
) |>
  group_by(group) |>
  slice_max(order_by = Count, n = 1, with_ties = FALSE)
```


#### Plot with ggraph

```{r}
set.seed(1234)

gg_coex_GO <- gg_coex |>
  activate(nodes) |>
  left_join(GO_coexp)

coexp_ggraph <- ggraph(gg_coex_GO, layout = "kk") +
  geom_edge_link(aes(edge_alpha = weight)) +
  geom_node_point(
    aes(fill = evidence),
    shape = 21,
    stroke = 0.5
  ) +
  geom_mark_hull(
    aes(
      x = x,
      y = y,
      group = group,
      label = group,
      description = paste0(Description, " (", GeneRatio, ")")
    ),
    colour = "black",
    expand = unit(1.5, "mm"),
    radius = unit(1.5, "mm"),
    label.fontsize = c(text_size * 1.3, text_size),
    label.family = "Helvetica",
    label.buffer = unit(0, "mm"),
    label.margin = margin(0.5, 0, 0.5, 0, "mm"),
    con.cap = unit(1, "mm")
  ) +
  geom_node_label(
    aes(label = label),
    fontface = "bold",
    # repel = TRUE,
    hjust = 1,
    nudge_x = -0.2,
    nudge_y = c(-0.15, 0.15),
    family = "Helvetica",
    colour = pal_ostwald_disc[1],
    size = ggtext_size,
    label.r = unit(0, "mm"),
    label.size = NA,
    fill = rgb(1, 1, 1, 0.5)
  ) +
  scale_fill_manual(values = c(pal_ostwald_disc[c(2, 1, 4)])) +
  theme_void() +
  theme(
    legend.position = "none"
  )

coexp_ggraph
```

# Alphafold predictions

## Export candidates

```{r}
candidates <- readxl::read_excel("data/coexpression/candidates.xlsx") |>
  mutate("candidate" = TRUE)
reported <- readxl::read_excel("data/coexpression/reported_interactors.xlsx") |>
  rename("interactome" = evidence)

ap2_cand <- full_join(candidates, reported) |>
  left_join(ctrl_data) |>
  mutate(n = case_when(
    is.na(n) ~ 0,
    TRUE ~ n
  ))

new <- ap2_cand |>
  filter(evidence == "New" & candidate == TRUE & n < 1) |>
  filter(interactome != "Widest") |>
  filter(protein != "P29514") # beta 6 tubulin

known_found <- ap2_cand |>
  filter(evidence != "New" & candidate == TRUE)

known_missing <- ap2_cand |>
  filter(is.na(evidence) & interactome == "Not detected") |>
  left_join(TORC_db, by = join_by(protein == stringId_B)) |>
  drop_na(stringId_A)

known_not_enriched <- ap2_cand |>
  filter(is.na(evidence) & interactome == "Not enriched")

export <- new |>
  select(protein) |>
  mutate(group = "New") |>
  bind_rows(known_found |> select(protein) |> mutate(group = "Published and enriched")) |>
  bind_rows(known_not_enriched |> select(protein) |> mutate(group = "Published and not enriched")) |>
  bind_rows(known_missing |> select(protein) |> mutate(group = "Published and not detected"))

# write_tsv(export, "data/AP2/AP_candidates.tsv")
```


## Load results

```{r}
ap2_data <- read_csv("data/AP2/result_df.csv") |>
  mutate(
    "comp" = str_extract(`saved folder`, "/([:alnum:]+___[:alnum:]+)$", group = 1),
    "TORC_SU" = str_extract(comp, str_c(TOR[1], LST8[1], RAPTOR[1], sep = "|")),
    "protein" = str_remove_all(comp, str_c(TORC_SU, "___", sep = "|"))
  )

export_ap2 <- ap2_data |>
  select(protein, TORC_SU, LIS, LIA) |>
  pivot_wider(
    names_from = TORC_SU,
    values_from = c(LIS, LIA)
  ) |>
  select(
    protein,
    "AlphaFold2 LIS with TOR" = LIS_Q9FR53,
    "AlphaFold2 LIA with TOR" = LIA_Q9FR53,
    "AlphaFold2 LIS with LST8-1" = LIS_Q9LV27,
    "AlphaFold2 LIA with LST8-1" = LIA_Q9LV27,
    "AlphaFold2 LIS with RAPTOR1" = LIS_Q93YQ1,
    "AlphaFold2 LIA with RAPTOR1" = LIA_Q93YQ1
  )

candidate_results <- export |>
  full_join(ap2_data) |>
  drop_na(Protein_1, group) |>
  group_by(protein, group) |>
  summarise(max_LIS = max(LIS))
```

## Plot overview

```{r}
letters <- letter_groups(
  candidate_results,
  max_LIS,
  group,
  "kruskal"
)

ap2_overview <- ggplot(
  candidate_results,
  aes(y = group, x = max_LIS, fill = group)
) +
  geom_density_ridges(
    # stat = "binline",
    # bins = 20,
    adjust = 5,
    colour = "white",
    quantile_lines = TRUE,
    quantiles = 2,
    alpha = 1,
    panel_scaling = FALSE
  ) +
  labs(
    x = "Local interaction score (LIS)"
  ) +
  scale_fill_manual(values = c(
    pal_ostwald_disc[c(2, 1)],
    colorspace::desaturate(colorspace::lighten(pal_ostwald_disc[1], 0.8), 0.6),
    colorspace::desaturate(colorspace::lighten(pal_ostwald_disc[1], 0.8), 0.6)
  )) +
  scale_x_continuous(labels = flat_zero) +
  coord_cartesian(xlim = c(-0.005, NA), expand = FALSE) +
  theme_leo() +
  theme(
    axis.title.x = element_markdown(),
    legend.position = "none"
  )

ap2_overview
```

# Revisions

## Quantify contribution of possible false-positives

```{r}
wider <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE/Q93YQ1_Q9LV27_P20081_min-3_ctrl-FALSE_GFP-TRUE_exclusive-FALSE_table.tsv"
  )
) |>
  distinct(protein, .keep_all = TRUE) |>
  filter(!is.na(`GO cellular component`)) |>
  mutate(
    "confidence" = case_when(
      !str_detect(`GO cellular component`, "cytosol|plasma membrane|chloroplast envelope|ribosome|microtubule|nucleus") &
        str_detect(`GO cellular component`, "chloroplast|mitochondrion|endoplasmic reticulum") ~ "low",
      .default = "high"
    )
  )

wider_low <- filter(wider, confidence == "low")

wider_low_manual <- read_tsv("data/published/manual_localisation.tsv") |>
  filter(alternative_explanation == "no")

wider_ratio <- nrow(wider_low_manual) / nrow(wider)

known <- c(
  leene_loci,
  persyn_loci
) |>
  unique()

known_annotated <- biomart(
  genes = known, # query genes
  mart = "plants_mart", # subject biomart
  dataset = "athaliana_eg_gene", # subject dataset
  attributes = c(
    "description", "external_synonym", "namespace_1003", "name_1006", "interpro_description"
  ), # subject attributes
  filters = "ensembl_gene_id" # ID type of the query
)

known_annotated_list <- known_annotated |>
  mutate(gene = ensembl_gene_id) |>
  group_by(gene, external_synonym, description, interpro_description) |>
  filter(namespace_1003 != "") |>
  pivot_wider(names_from = namespace_1003, values_from = name_1006, values_fn = ~ paste(sort(unique(.x)), collapse = "; ")) |>
  group_by(gene) |>
  summarise(
    Synonyms = paste(unique(external_synonym), collapse = ";<br>"),
    `GO cellular component` = paste(unique(cellular_component), collapse = "; "),
    `GO biological process` = paste(unique(biological_process), collapse = "; "),
    `GO molecular function` = paste(unique(molecular_function), collapse = "; "),
    Description = unique(description),
    `Interpro terms` = paste(
      unique(interpro_description),
      collapse = "; "
    )
  ) |>
  filter(!is.na(`GO cellular component`)) |>
  mutate(
    "confidence" = case_when(
      !str_detect(`GO cellular component`, "cytosol|plasma membrane|chloroplast envelope|ribosome|microtubule|nucleus") &
        str_detect(`GO cellular component`, "chloroplast|mitochondrion|endoplasmic reticulum") ~ "low",
      .default = "high"
    )
  )
known_low <- filter(known_annotated_list, confidence == "low")
known_ratio <- (nrow(known_low) - 1) / nrow(known_annotated_list) # AT4G37190 is likely cytosolic, hence the subtraction

cat(
  paste0(
    "Based on available localisation data, ",
    round(wider_ratio * 100, digits = 0),
    "% of proteins in the 'Wider' interactome appear unlikely to be true positives.",
    " The corresponding proportion for the data published by Van Leene et al. (2019) and Persyn et al. (2024) is ",
    round(known_ratio * 100, digits = 0), "%."
  )
)
```


## Highlighting novel pathways vs Leene/Persyn

### KEGG pathways vs previous reports

```{r}
wider_novel <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE/Q93YQ1_Q9LV27_P20081_min-3_ctrl-FALSE_GFP-TRUE_exclusive-FALSE_table.tsv"
  )
) |>
  distinct(protein) |>
  filter(!(protein %in% c(leene_proteins, persyn_proteins))) |>
  drop_na() |>
  pull(protein) |>
  map_vec(get_gene, .progress = TRUE)

wider <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE/Q93YQ1_Q9LV27_P20081_min-3_ctrl-FALSE_GFP-TRUE_exclusive-FALSE_table.tsv"
  )
) |>
  distinct(protein) |>
  drop_na() |>
  pull(protein) |>
  map_vec(get_gene, .progress = TRUE)

known <- c(
  leene_proteins,
  persyn_proteins
) |>
  unique() |>
  map_vec(get_gene, .progress = TRUE)

wider_novel_kegg <- enrichKEGG(
  wider_novel,
  organism = "ath"
)

wider_kegg <- enrichKEGG(
  wider,
  organism = "ath"
)

known_kegg <- enrichKEGG(
  known,
  organism = "ath"
)

wider_novel_kegg@result |>
  filter(p.adjust < 0.05)

wider_kegg@result |>
  filter(p.adjust < 0.05)
# filter(ID == "ath04136") #autophagy
# filter(ID == "ath00750") #B6 metabolism

known_kegg@result |>
  filter(p.adjust < 0.05)
```

### Identify FKBP-associated TOR interactors

```{r}
widest <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE/Q93YQ1_Q9LV27_P20081_min-2_ctrl-FALSE_GFP-FALSE_exclusive-FALSE_table.tsv"
  )
) |>
  distinct(protein) |>
  drop_na() |>
  pull(protein)

fkbp_spec <- R1017 |>
  filter(logFC > 1 & adjPval < 0.05) |>
  filter(!(protein %in% widest)) |>
  pull(protein) |>
  map_vec(get_gene, .progress = TRUE)

fkbp_kegg <- enrichKEGG(
  fkbp_spec,
  organism = "ath"
)

## no GO terms enriched at p < 0.01 ##
fkbp_GO <- clusterProfiler::enrichGO(
  gene = fkbp_spec,
  OrgDb = "org.At.tair.db",
  keyType = "TAIR",
  ont = "BP",
  pvalueCutoff = 0.05,
) |>
  clusterProfiler::simplify()

fkbp_kegg
```

### Large Venn with assocaited KEGG tables

#### Enrichment analyses

```{r}
wider <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE/Q93YQ1_Q9LV27_P20081_min-3_ctrl-FALSE_GFP-TRUE_exclusive-FALSE_table.tsv"
  )
) |>
  distinct(protein) |>
  drop_na() |>
  pull(protein)

fkbp <- R1017 |>
  filter(logFC > 1 & adjPval < 0.05) |>
  pull(protein)

known <- c(
  leene_proteins,
  persyn_proteins
) |>
  unique()

overlaps <- data.frame(
  protein = c(wider, fkbp, known)
) |>
  distinct(protein) |>
  mutate(
    "ScFKBP" = case_when(
      protein %in% fkbp ~ TRUE,
      TRUE ~ FALSE
    ),
    "Wider" = case_when(
      protein %in% wider ~ TRUE,
      TRUE ~ FALSE
    ),
    "Published" = case_when(
      protein %in% known ~ TRUE,
      TRUE ~ FALSE
    )
  )

overlap_loci <- map_vec(overlaps$protein, get_gene, .progress = TRUE)

overlaps$locus <- overlap_loci

overlap_kegg <- overlaps |>
  select(-protein) |>
  group_by(ScFKBP, Wider, Published) |>
  summarise(data = list(locus)) |>
  mutate(
    kegg = map(
      data, \(x) enrichKEGG(
        x,
        organism = "ath"
      )
    )
  )

overlap_kegg_tables <- overlap_kegg |>
  mutate(tables = map(
    kegg,
    \(x) x@result
  ))

overlap_go <- overlaps |>
  select(-protein) |>
  group_by(ScFKBP, Wider, Published) |>
  summarise(data = list(locus)) |>
  mutate(
    go = map(
      data,
      \(x) clusterProfiler::enrichGO(
        gene = x,
        OrgDb = "org.At.tair.db",
        keyType = "TAIR",
        ont = "BP",
        pvalueCutoff = 0.05,
      ) |>
        clusterProfiler::simplify()
    )
  )

overlap_go_tables <- overlap_go |>
  mutate(tables = map(
    go,
    \(x) x@result
  ))
```

#### Plot diagram

```{r}
euler_overlaps <- euler(
  select(overlaps, -protein, -locus),
  shape = "ellipse"
)

euler_plot <- plot(
  euler_overlaps,
  quantities = list(fontfamily = "Helvetica", fontsize = text_size),
  # edges = list(lty = 2),
  labels = list(fontfamily = "Helvetica", fontsize = text_size),
  # legend = list(
  #   labels = c(
  #     "FKBP-specific",
  #     "This study",
  #     "Previous publications"
  #   ),
  #   fontfamily = "Helvetica",
  #   fontsize = text_size
  # ),
  fill = c(
    pal_ostwald_disc[c(1, 2, 4)]
  )
)

pdf("venn_revisions.pdf", width = twocol * 1.2, height = onecol * 1.2)
euler_plot
dev.off()

euler_plot
```

#### Generate tables

```{r}
for (i in 1:7) {
  name <- paste0(
    "tab_wider-", overlap_kegg_tables$Wider[[i]],
    "_fkbp-", overlap_kegg_tables$ScFKBP[[i]],
    "_pub-", overlap_kegg_tables$Published[[i]]
  )

  if (nrow(filter(overlap_kegg_tables$tables[[i]], p.adjust < 0.05)) > 0) {
    overlap_kegg_tables$tables[[i]] |>
      filter(p.adjust < 0.05) |>
      select(
        ID,
        # subcategory,
        Description,
        Count,
        "Fold-enrich." = FoldEnrichment,
        "Adj. *P*" = p.adjust
      ) |>
      mutate(
        Description = str_remove(Description, fixed(" - Arabidopsis thaliana (thale cress)")),
        `Fold-enrich.` = round(`Fold-enrich.`, digits = 1),
        `Adj. *P*` = case_when(
          round(`Adj. *P*`, digits = 4) > 0 ~ as.character(formatC(`Adj. *P*`, format = "f", digits = 4)),
          .default = "< 0.0001"
        )
      ) |>
      gt() |>
      cols_label(
        `Adj. *P*` = md("Adj. *P*")
      ) |>
      opt_table_font(
        font = "Helvetica",
        size = px(12)
      ) |>
      cols_align(
        align = "right",
        columns = 5
      ) |>
      tab_options(table.width = px(475)) |>
      gtsave(
        paste0(out_path, name, ".html")
      )

    # system(paste0("wkhtmltopdf ", name, ".html ", name, ".pdf"))
  }
}
```


## Compare ctrl vs sucrose-induced interactions

### GO enrichment

```{r}
suc_spec <- ind_treat_data |>
  filter(suc > 1 & suc_P < 0.05 & man < 1) |>
  pull(protein) |>
  unique() |>
  map_vec(get_gene, .progress = TRUE)


man_spec <- ind_treat_data |>
  filter(man > 1 & man_P < 0.05 & suc < 1) |>
  pull(protein) |>
  unique() |>
  map_vec(get_gene, .progress = TRUE)

suc_GO <- clusterProfiler::enrichGO(
  gene = suc_spec,
  OrgDb = "org.At.tair.db",
  keyType = "TAIR",
  ont = "BP",
  pvalueCutoff = 0.01,
) |>
  clusterProfiler::simplify()

man_GO <- clusterProfiler::enrichGO(
  gene = man_spec,
  OrgDb = "org.At.tair.db",
  keyType = "TAIR",
  ont = "BP",
  pvalueCutoff = 0.01,
) |>
  clusterProfiler::simplify()
```

### Plot

#### Sucrose

```{r}
suc_go_df <- suc_GO@result |>
  mutate(
    GeneProp = Count / as.numeric(str_extract(GeneRatio, "[:digit:]+$")),
    Recall = Count / as.numeric(str_extract(BgRatio, "^[:digit:]+")),
    label = paste0(Description, "<br>(", ID, ")"),
  ) |>
  slice_max(Recall, n = 10)


suc_enrich_plot <- ggplot(
  suc_go_df,
  aes(x = fct_reorder(label, Recall, .desc = TRUE), y = Recall)
) +
  geom_col(
    width = 0.1,
    fill = "black"
  ) +
  geom_point(
    aes(size = Count, fill = p.adjust),
    shape = 21,
    stroke = 0.4
  ) +
  geom_text(
    aes(label = Count, colour = p.adjust > 5e-03),
    family = "Helvetica",
    size = ggtext_size,
    hjust = 0.5
  ) +
  scale_color_manual(values = c("white", "black"), guide = "none") +
  scale_size(
    # limits = c(0, 18),
    range = c(3, 8),
    breaks = c(6, 9),
    guide = "none"
  ) +
  scale_fill_distiller(
    name = "Adjusted *P*",
    palette = "Reds",
    limits = c(3e-07, 7e-03),
    breaks = c(1e-06, 0.005),
    guide = guide_colorbar(
      direction = "horizontal",
      title.position = "top"
    )
  ) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.075)), labels = flat_zero) +
  labs(
    y = "Recall",
    title = "Sucrose specific interactors"
  ) +
  theme_leo() +
  theme(
    axis.ticks.x = element_line(
      linewidth = 0.4,
      colour = "black",
      lineend = "square"
    ),
    axis.title.y = element_blank(),
    axis.title.x = element_markdown(),
    legend.title = element_markdown(lineheight = 0.7),
    # legend.position = "bottom",
    legend.key.height = unit(2.5, "mm"),
    legend.key.width = unit(2.5, "mm"),
    legend.position = "inside",
    legend.position.inside = c(1, 1),
    legend.justification = c(1, 1),
    legend.spacing = unit(1, "mm"),
    legend.box.just = "left",
    legend.key.spacing = unit(1, "mm"),
    legend.box.spacing = unit(1, "mm")
  ) +
  coord_flip()

suc_enrich_plot
```

#### Mannitol

```{r}
man_go_df <- man_GO@result |>
  mutate(
    GeneProp = Count / as.numeric(str_extract(GeneRatio, "[:digit:]+$")),
    Recall = Count / as.numeric(str_extract(BgRatio, "^[:digit:]+")),
    label = paste0(Description, "<br>(", ID, ")"),
  ) |>
  slice_max(Recall, n = 10)


man_enrich_plot <- ggplot(
  man_go_df,
  aes(x = fct_reorder(label, Recall, .desc = TRUE), y = Recall)
) +
  geom_col(
    width = 0.1,
    fill = "black"
  ) +
  geom_point(
    aes(size = Count, fill = p.adjust),
    shape = 21,
    stroke = 0.4
  ) +
  geom_text(
    aes(label = Count, colour = p.adjust > 5e-03),
    family = "Helvetica",
    size = ggtext_size,
    hjust = 0.5
  ) +
  scale_color_manual(values = c("white", "black"), guide = "none") +
  scale_size(
    range = c(3, 8),
    breaks = c(8, 20),
    guide = "none"
  ) +
  scale_fill_distiller(
    name = "Adjusted *P*",
    palette = "Reds",
    limits = c(3e-07, 7e-03),
    # breaks = c(0.001, 0.005),
    guide = "none"
  ) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.075)), labels = flat_zero) +
  labs(
    y = "Recall",
    title = "Mannitol specific interactors"
  ) +
  theme_leo() +
  theme(
    axis.ticks.x = element_line(
      linewidth = 0.4,
      colour = "black",
      lineend = "square"
    ),
    axis.title.y = element_blank(),
    axis.title.x = element_markdown(),
    legend.title = element_markdown(lineheight = 0.7),
    # legend.position = "bottom",
    legend.key.height = unit(2.5, "mm"),
    legend.key.width = unit(2.5, "mm"),
    legend.position = "inside",
    legend.position.inside = c(1, 1),
    legend.justification = c(1, 1),
    legend.spacing = unit(1, "mm"),
    legend.box.just = "left",
    legend.key.spacing = unit(1, "mm"),
    legend.box.spacing = unit(1, "mm")
  ) +
  coord_flip()

man_enrich_plot
```


# Main figures

## Figure 1

### 2024-10

```{r}
set.seed(6235)

design <- "
##AB
CDEF
GGGH
"
fig2 <- list(
  # raptor_comp_plot,
  # plot_spacer(),
  # azd_plot,
  const_volc(1) + guides(fill = "none"),
  const_volc(2) + guides(fill = "none"),
  ind_volc(1) + guides(fill = "none"),
  ind_volc(2),
  ind_treat_scatter(1, "_24h") + guides(fill = "none"),
  ind_treat_scatter(2, "_24h") + guides(fill = "none"),
  comp_plot,
  const_volc(3) + guides(fill = "none")
  # upset_baits
)
# G <- access_plot(detected, depth, top_depth)  + labs(y = "LYS distance from surface [Å]")
# H <- access_plot(detected, rsa, top_depth) + labs(y = "LYS solvent acessibility")
# I <- access_plot(detected, idr, top_depth) + labs(y = "LYS disorder")
# J <- access_plot(det_en, idr, top_depth) +
#   labs(y = "LYS disorder") +
#   scale_x_discrete(labels = c("Enriched", "Detected but<br>not enriched"))

# pdf("Figure2.pdf", width = twocol, height = twocol)

wrap_plots(fig2, design = design) +
  # wrap_elements(plot = upset_baits) +
  plot_annotation(tag_levels = list(LETTERS[2:9])) &
  theme(
    # legend.position = "bottom",
    plot.tag = element_text(size = 10, face = "bold", family = "Helvetica")
  )
# dev.off()

ggsave(
  "Figure1.pdf",
  width = 180,
  height = 150,
  units = "mm"
)
```

## Figure 2

### 2024-10

```{r}
design <- "
AAAA
AAAA
AAAA
AAAA
AAAA
AAAA
##BC
##DE
"

c <- access_plot(detected, count, full_depth) + labs(y = "Surface Lys")
d <- access_plot(detected, count, full_rsa) + labs(y = "Solvent accessible Lys")
e <- access_plot(detected, idr, top_depth) + labs(y = "LYS disorder")
f <- access_plot(det_en, idr, top_depth) +
  labs(y = "LYS disorder") +
  scale_x_discrete(labels = c("Enriched", "Detected but<br>not enriched"))

top <- hm_dendro + hm + sig_bar + evidence_bar +
  plot_layout(
    ncol = 4,
    widths = c(1, 10, 0.25, 0.25)
  )

wrap_elements(full = top) + c + d + e + f +
  plot_layout(design = design) +
  plot_annotation(tag_levels = list(LETTERS[c(1, 3:6)])) &
  theme(
    plot.tag = element_text(size = 10, face = "bold", family = "Helvetica")
  )

ggsave(
  "Figure2.pdf",
  width = 180,
  height = 180,
  units = "mm"
)
```

## Figure 3

### 2024-10

```{r}
design <- "
AABBCC
AABBDD
EEEFFF
EEEFFF
"

FC_phospho_scatter("4h") + theme(legend.position = "none") +
  FC_phospho_scatter("24h") +
  SP_logo +
  RS_logo +
  free(ap2_overview) +
  plot_spacer() +
  plot_annotation(tag_levels = "A") +
  plot_layout(
    design = design
  ) &
  theme(
    plot.tag = element_text(size = 10, face = "bold", family = "Helvetica")
  )

ggsave(
  "Figure3.pdf",
  width = 180,
  height = 100,
  units = "mm"
)
```

# Supplementary figures

## Tobacco 

```{r}
Nb_volc

# ggsave(
#   "FigureS1.pdf",
#   width = onecol * 0.75,
#   height = onecol * 0.75
# )
```

## Raptor/AZD seedlings

```{r}
design <- "
#A
#B
"
raptor_comp_plot + azd_plot +
  plot_layout(design = design) +
  plot_annotation(tag_levels = list(LETTERS[c(2, 4)])) &
  theme(
    plot.tag = element_text(size = 10, face = "bold", family = "Helvetica")
  )

# ggsave(
#   "FigureS2.pdf",
#   width = onecol,
#   height = onecol
# )
```


S2: Assembled in Inkscape.

## 35S vs XVE

```{r}
design <- "
AAABBB
AAABBB
CCCCCC
DDDEEE
DDDEEE
"

free(FC_treat_scatter(1)) + theme(legend.position = c(0, 1), legend.justification = c(0, 1)) +
  free(FC_treat_scatter(2)) + guides(fill = "none") +
  wrap_elements(full = upset_constructs) +
  suc_enrich_plot + man_enrich_plot +
  plot_layout(design = design) +
  plot_annotation(tag_levels = "A") &
  theme(
    plot.tag = element_text(size = 10, face = "bold", family = "Helvetica")
  )

# ggsave(
#   "FigureS3.pdf",
#   width = twocol,
#   height = twocol
# )
```

## FKBP seedlings

S4: Assembled in Inkscape.

## Upset

```{r}
upset_baits

# ggsave(
#   "FigureS5.pdf",
#   width = twocol,
#   height = onecol
# )
```

## Co-expression

```{r}
design <- "
AABBB
CCCCC
CCCCC
CCCCC
CCCCC
"

coexp_dist + coexp_logfc + free(coexp_ggraph) +
  plot_layout(design = design) +
  plot_annotation(tag_levels = "A") &
  theme(
    plot.tag = element_text(size = 10, face = "bold", family = "Helvetica"),
    plot.margin = margin(0.1, 0.1, 0.1, 0.1, "mm")
  )

# ggsave(
#   "FigureS7.pdf",
#   width = twocol * 1.025,
#   height = onehalfcol * 1.025,
#   units = "in"
# )
```


## Table of individual experiments

```{r}
stats <- interactions |>
  filter(logFC > 1 & adjPval < 0.05) |>
  filter(batch %in% c("R0722", "R0967", "R1017")) |>
  separate_wider_delim(
    group1,
    names = c("bait_species", "bait_construct", "bait_protein", "bait_treatment", "bait_time"),
    delim = "_",
    cols_remove = FALSE
  ) |>
  separate_wider_delim(
    group2,
    names = c("control_species", "control_construct", "control_protein", "control_treatment", "control_time"),
    delim = "_",
    cols_remove = FALSE
  ) |>
  filter(
    (bait_treatment == control_treatment & bait_time == control_time & bait_protein != "GFP" & control_protein == "GFP") | # compare baits
      (bait_protein == "FKBP12" & bait_time == control_time & bait_treatment == "rap") # add ScFKBP
  ) |>
  left_join(
    db_list[[4]],
    by = join_by(protein == stringId_B)
  ) |>
  left_join(
    leene_data |> distinct(stringId, .keep_all = TRUE),
    by = join_by(
      protein == stringId
    )
  ) |>
  mutate(
    instance = paste(batch, bait_protein, bait_treatment, bait_time),
    string = !is.na(stringId_A),
    leene = !is.na(method)
  ) |>
  group_by(batch, bait_protein, bait_treatment, bait_time) |>
  summarise(
    total = n(),
    prev_evidence = sum(string | leene),
    string = sum(string),
    leene = sum(leene)
  ) |>
  mutate(
    Expression = case_when(
      batch == "R0967" ~ "Inducible",
      TRUE ~ "Constitutive"
    ),
    bait_protein = str_replace(bait_protein, "LST8", "LST8-1"),
    bait_protein = str_replace(bait_protein, "RAPTOR", "RAPTOR1"),
    bait_protein = str_replace(bait_protein, "FKBP12", "ScFKBP"),
    bait_time = str_replace(bait_time, "h", " h"),
    bait_treatment = str_replace(bait_treatment, "suc", "Sucrose"),
    bait_treatment = str_replace(bait_treatment, "man|ctrl", "Mannitol"),
    bait_treatment = str_replace(bait_treatment, "rap", "Rapamycin")
  ) |>
  ungroup() |>
  select(
    "Bait" = bait_protein,
    Expression,
    "Treatment" = bait_treatment,
    "Time" = bait_time,
    "Total" = total,
    "StringDB" = string,
    "Van Leene et al., 2019" = leene
  )

tt(stats)
# save_tt("tabS1.docx", overwrite = TRUE)
```

# Supplemental data files

```{r}
# TODO:
# [x] Protein
# [x] Gene
# [x] LST8-1 exps
# [x] RAPTOR1 exps
# [x] FKBP12 exps
# [x] LST8-1 cum. logFC
# [x] RAPTOR1 cum. logFC
# [x] FKBP12 cum. logFC
# [x] Interactome
# [x] Proteomics module (fig. 3)
# [x] Transcriptomics cluster (fig. SX)
# [x] Found with unrelated baits
# [x] LST8-1 AP2 multimer LIS
# [x] RAPTOR1 AP2 multimer LIS
# [x] TOR AP2 multimer LIS
# [x] Experimental evidence in StringDB v12
# [x] Found by Van Leene et al., 2019
# [x] Found by Persyn et al., 2019

export_legend <- tribble(
  ~Column, ~Explanation,
  "Protein", "Uniprot identifier of the identified protein",
  "Gene", "Arabidopsis locus encoding the respective protein",
  "Synonyms–Interpro terms", "Functional annotations",
  "Cumulative logFC LST8/ScFKBP/RAPTOR1", "Highest log10(fold-change) enrichment of the protein with the respective bait; if the protein was enriched with the respective bait in multiple experiments, the logFC values of the individual experiments are summed up",
  "Comparisons LST8/ScFKBP/RAPTOR1", "Comparisons between samples from different baits/treatments/timepoints in which the protein was significantly enriched with the respective bait",
  "Interactome", "Which of the proposed TOR interactome the protein qualifies for; if empty, the protein was found significantly enriched, but not robustly enough to qualify for the 'widest' interactome",
  "Proteomics module", "Which module the protein clustered in (cf. figure 3A)",
  "Coexpression cluster", "cf. figure S7",
  "Found with unrelated baits", "Whether the protein was also found with baits that are not known to be involved in TOR signalling; indicates whether a protein is a highly specific or promiscuous interactor",
  "Enriched phosphosites", "Phosphorylated residues that were enriched with LST81 or RAPTOR1",
  "AlphaFold2 LIS/LIA with TOR/LST8-1/RAPTOR1", "Local Interaction Score and Local Interaction Area of the interaction with the respective TORC subunit as predicted by AlphaFold2 multimer",
  "StringDB exp. evidence with TOR/LST8-1/RAPTOR1", "Experimental evidence in StringDB (v12) for the interaction with the respective TORC subunit",
  "Evidence from Leene et al. (2019)", "Whether evidence for the respective interaction was found in https://doi.org/10.1038/s41477-019-0378-z",
  "Evidence from Persyn et al. (2024)", "Whether evidence for the respective interaction was found in https://doi.org/10.1016/j.mcpro.2024.100842"
)

export_annotation <- interactions |>
  group_by(protein) |>
  select(11:17) |>
  summarise(across(everything(), ~ unique(.x))) |>
  rename("Gene" = gene) |>
  mutate("Synonyms" = str_replace_all(Synonyms, "<br>", "; ")) |>
  mutate("Synonyms" = str_replace_all(Synonyms, ";;", ";")) |>
  mutate("Synonyms" = str_replace_all(Synonyms, "'", "")) |>
  mutate("Synonyms" = str_replace_all(Synonyms, '"', ""))

export_string <- TORC_db |>
  select(preferredName_A, "protein" = stringId_B, escore) |>
  mutate(preferredName_A = paste("StringDB exp. evidence with", preferredName_A)) |>
  pivot_wider(id_cols = protein, names_from = preferredName_A, values_from = escore)

export_leene <- leene_data |>
  select("protein" = stringId) |>
  mutate("Evidence from Leene et al. (2019)" = "Yes") |>
  distinct()

export_persyn <- persyn_data |>
  select("protein" = stringId) |>
  mutate("Evidence from Persyn et al. (2024)" = "Yes") |>
  distinct()

export_cotrol_data <- ctrl_data |>
  select(protein) |>
  mutate("Found with unrelated baits" = "Yes")

core <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE/Q93YQ1_Q9LV27_P20081_min-5_ctrl-FALSE_GFP-TRUE_exclusive-FALSE_table.tsv"
  )
) |>
  distinct(protein) |>
  drop_na() |>
  pull(protein)

wider <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE/Q93YQ1_Q9LV27_P20081_min-3_ctrl-FALSE_GFP-TRUE_exclusive-FALSE_table.tsv"
  )
) |>
  distinct(protein) |>
  drop_na() |>
  pull(protein)

widest <- read_tsv(
  paste0(
    out_path,
    "FP_maxLFQ-TRUE_hurdle-FALSE_glMinProb-TRUE/Q93YQ1_Q9LV27_P20081_min-2_ctrl-FALSE_GFP-FALSE_exclusive-FALSE_table.tsv"
  )
) |>
  distinct(protein) |>
  drop_na() |>
  pull(protein)


full_export <- interactions |>
  select(-c(11:17)) |>
  separate_wider_delim(
    group1,
    names = c("bait_species", "bait_construct", "bait_protein", "bait_treatment", "bait_time"),
    delim = "_",
    cols_remove = FALSE
  ) |>
  separate_wider_delim(
    group2,
    names = c("control_species", "control_construct", "control_protein", "control_treatment", "control_time"),
    delim = "_",
    cols_remove = FALSE
  ) |>
  filter(logFC >= 0) |>
  filter(bait_protein != "GFP") |>
  filter(
    (bait_treatment == control_treatment & bait_time == control_time) | # compare baits
      (bait_protein == control_protein & bait_time == control_time) | # compare treatments
      (bait_treatment == control_treatment & bait_protein == control_protein) | # compare time points
      (bait_protein == "FKBP12" & bait_time == control_time) # compare rapamycin treatment
  ) |>
  group_by(protein, batch, bait_protein) |>
  summarise(
    max_logFC = max(logFC),
    p_val = adjPval[logFC == max(logFC)],
    comparisons = str_c(paste(group1, group2, sep = " vs. ", collapse = "; "))
  ) |>
  group_by(protein, bait_protein) |>
  summarise(
    Comparisons = str_c(comparisons, collapse = "; "),
    `Cumulative logFC` = sum(max_logFC[max_logFC >= 1 & p_val < 0.05])
  ) |>
  mutate(
    `Cumulative logFC` = case_when(`Cumulative logFC` == 0 ~ NA, TRUE ~ `Cumulative logFC`)
  ) |>
  drop_na(`Cumulative logFC`) |>
  pivot_wider(
    names_from = bait_protein,
    values_from = c(Comparisons, `Cumulative logFC`),
    names_sep = " ",
    values_fill = NA
  ) |>
  left_join(export_annotation) |>
  mutate(
    "Interactome" = case_when(
      protein %in% core ~ "Core",
      protein %in% wider ~ "Wider",
      protein %in% widest ~ "Widest",
      TRUE ~ NA
    )
  ) |>
  left_join(export_clusters) |>
  left_join(export_coex_clusters) |>
  left_join(export_cotrol_data) |>
  mutate("Found with unrelated baits" = case_when(
    is.na(`Found with unrelated baits`) ~ "No",
    TRUE ~ `Found with unrelated baits`
  )) |>
  left_join(export_sig_sites) |>
  left_join(export_ap2) |>
  left_join(export_string) |>
  left_join(export_leene) |>
  left_join(export_persyn) |>
  select(
    "Protein" = protein,
    8:14,
    5:7,
    2:4,
    15:30
  ) |>
  arrange(Interactome, `Found with unrelated baits`, `Enriched phosphosites`)

export_legend

full_export

# writexl::write_xlsx(
#   list(
#     "Column explanations" = export_legend,
#     "Database" = full_export
#   ),
#   "Supplementary_data_3.xlsx"
#   )
```

# References

# Session info

```{r}
sessionInfo()
```
